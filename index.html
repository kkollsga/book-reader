<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Book Reader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'true-black': '#000000'
                    }
                }
            }
        }
    </script>
    <style>
        .controls-hidden { opacity: 0; pointer-events: none; }
        .controls-visible { opacity: 1; pointer-events: auto; }
        .nav-controls { transition: opacity 0.2s ease-in-out; }
        
        /* Theme aware content styles */
        .chapter-loaded {
            color: rgb(17, 24, 39) !important; /* text-gray-900 */
            background-color: white !important;
        }
        
        .dark .chapter-loaded {
            color: rgb(243, 244, 246) !important; /* text-gray-100 */
            background-color: black !important;
        }
        
        .chapter-loaded * {
            background-color: inherit !important;
            color: inherit !important;
        }

        /* Line highlighting */
        .line-highlight {
            position: relative;
        }

        .line-highlight::before,
        .line-highlight::after {
            content: '';
            position: absolute;
            left: -20px;
            right: -20px;
            height: 1px;
            background: rgba(59, 130, 246, 0.4);
            transition: opacity 0.2s ease;
        }

        .line-highlight::before {
            top: -2px;
        }

        .line-highlight::after {
            bottom: -2px;
        }

        .dark .line-highlight::before,
        .dark .line-highlight::after {
            background: rgba(147, 197, 253, 0.4);
        }

        /* Text highlights */
        .text-highlight {
            padding: 2px 4px;
            border-radius: 6px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .text-highlight.selected {
            outline: 2px solid #3b82f6;
            outline-offset: 1px;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Highlight colors */
        .highlight-yellow { background-color: rgba(254, 240, 138, 0.6); }
        .highlight-green { background-color: rgba(187, 247, 208, 0.6); }
        .highlight-blue { background-color: rgba(191, 219, 254, 0.6); }
        .highlight-pink { background-color: rgba(251, 207, 232, 0.6); }
        .highlight-purple { background-color: rgba(221, 214, 254, 0.6); }
        .highlight-orange { background-color: rgba(253, 186, 116, 0.6); }

        .dark .highlight-yellow { background-color: rgba(254, 240, 138, 0.3); }
        .dark .highlight-green { background-color: rgba(187, 247, 208, 0.3); }
        .dark .highlight-blue { background-color: rgba(191, 219, 254, 0.3); }
        .dark .highlight-pink { background-color: rgba(251, 207, 232, 0.3); }
        .dark .highlight-purple { background-color: rgba(221, 214, 254, 0.3); }
        .dark .highlight-orange { background-color: rgba(253, 186, 116, 0.3); }

        /* Popup menu */
        .highlight-popup {
            position: fixed;
            z-index: 1000;
            background: white;
            border: 1px solid rgb(229, 231, 235);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            min-width: 300px;
            max-width: 350px;
            user-select: none;
            -webkit-user-select: none;
            backdrop-filter: blur(8px);
            transform: translateY(-10px);
            opacity: 0;
            transition: all 0.2s ease;
        }

        .highlight-popup.show {
            transform: translateY(0);
            opacity: 1;
        }

        .dark .highlight-popup {
            background: rgba(17, 24, 39, 0.95);
            border-color: rgb(75, 85, 99);
        }

        .color-pills {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
            justify-content: center;
        }

        .color-pill {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .color-pill:hover {
            border-color: #3b82f6;
            transform: scale(1.15);
        }

        .color-pill.selected {
            border-color: #3b82f6;
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .color-pill.yellow { background-color: rgb(254, 240, 138); }
        .color-pill.green { background-color: rgb(187, 247, 208); }
        .color-pill.blue { background-color: rgb(191, 219, 254); }
        .color-pill.pink { background-color: rgb(251, 207, 232); }
        .color-pill.purple { background-color: rgb(221, 214, 254); }
        .color-pill.orange { background-color: rgb(253, 186, 116); }

        .popup-comment {
            font-size: 14px;
            color: rgb(75, 85, 99);
            margin-bottom: 12px;
            max-height: 80px;
            overflow-y: auto;
            padding: 8px;
            background: rgb(249, 250, 251);
            border-radius: 6px;
            min-height: 40px;
            display: flex;
            align-items: center;
        }

        .dark .popup-comment {
            color: rgb(156, 163, 175);
            background: rgb(31, 41, 55);
        }

        .popup-controls {
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }

        .popup-button {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
            flex: 1;
        }

        .edit-button {
            background: rgb(59, 130, 246);
            color: white;
        }

        .edit-button:hover {
            background: rgb(37, 99, 235);
            transform: translateY(-1px);
        }

        .delete-button {
            background: rgb(239, 68, 68);
            color: white;
        }

        .delete-button:hover {
            background: rgb(220, 38, 38);
            transform: translateY(-1px);
        }

        .comment-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid rgb(209, 213, 219);
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: rgb(17, 24, 39);
            transition: border-color 0.2s ease;
        }

        .comment-input:focus {
            outline: none;
            border-color: rgb(59, 130, 246);
        }

        .dark .comment-input {
            background: rgb(31, 41, 55);
            border-color: rgb(75, 85, 99);
            color: rgb(243, 244, 246);
        }

        .dark .comment-input:focus {
            border-color: rgb(147, 197, 253);
        }

        /* Prevent text selection during highlighting operations */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="bg-white dark:bg-true-black text-gray-900 dark:text-white min-h-screen transition-colors duration-200">
    <div class="min-h-screen flex flex-col">
        <div id="topSentinel" class="absolute top-0 h-1 w-full pointer-events-none"></div>
        
        <div id="header" class="fixed top-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-b border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="titleButton" onclick="document.getElementById('fileInput').click()" 
                        class="text-left hover:text-gray-600 dark:hover:text-gray-300 transition-colors cursor-pointer truncate flex-1">
                    <span id="currentBookTitle" class="text-lg font-medium">Select a Book...</span>
                </button>
                <input type="file" id="fileInput" accept=".html" class="hidden">

                <select id="tocSelect" class="ml-4 bg-transparent focus:outline-none hover:text-gray-600 dark:hover:text-gray-300 dark:text-white focus:text-gray-900 dark:focus:text-white cursor-pointer text-sm min-w-[200px]">
                    <option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>
                </select>

                <button id="darkModeToggle" class="ml-4 p-2 hover:text-gray-600 dark:hover:text-gray-300 transition-colors">
                    <i class="fas fa-moon text-blue-500 dark:hidden"></i>
                    <i class="fas fa-sun text-yellow-500 hidden dark:inline"></i>
                </button>
            </div>
        </div>

        <div id="contentWrapper" class="flex-1 overflow-y-auto bg-white dark:bg-true-black pt-12 pb-12">
            <div id="topSentinel" class="sticky top-0 h-1 w-full pointer-events-none"></div>
            
            <div id="bookContent" class="max-w-3xl mx-auto px-4">
                <div class="chapter-loaded">
                </div>
            </div>
            
            <div id="bottomSentinel" class="sticky bottom-0 h-1 w-full pointer-events-none"></div>
        </div>

        <div id="footer" class="fixed bottom-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-t border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="prevButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    ← Previous
                </button>
                <div id="pageIndicator" class="text-gray-500 dark:text-gray-400 text-sm">Page 0 of 0</div>
                <button id="nextButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    Next →
                </button>
            </div>
        </div>
    </div>

    <!-- Highlight popup menu -->
    <div id="highlightPopup" class="highlight-popup">
        <div class="color-pills">
            <div class="color-pill yellow" data-color="yellow"></div>
            <div class="color-pill green" data-color="green"></div>
            <div class="color-pill blue" data-color="blue"></div>
            <div class="color-pill pink" data-color="pink"></div>
            <div class="color-pill purple" data-color="purple"></div>
            <div class="color-pill orange" data-color="orange"></div>
        </div>
        <div class="popup-comment" id="highlightComment">Click edit to add a comment</div>
        <div class="popup-controls">
            <button class="popup-button edit-button" id="editCommentBtn">Edit</button>
            <button class="popup-button delete-button" id="deleteHighlightBtn">Delete</button>
        </div>
    </div>

<script>
class HighlightManager {
    constructor(bookReader) {
        this.bookReader = bookReader;
        this.highlights = new Map(); // pageNum -> highlights array
        this.selectedHighlight = null;
        this.popup = document.getElementById('highlightPopup');
        this.isEditingComment = false;
        this.currentLineHighlight = null;
        
        // Touch handling
        this.touchStartTime = 0;
        this.touchStartPos = null;
        this.lastTapTime = 0;
        this.tapDelay = 300;
        
        this.setupEventListeners();
        this.loadHighlights();
    }

    setupEventListeners() {
        const bookContent = document.getElementById('bookContent');
        
        // Touch events for selection and line highlighting
        bookContent.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });
        bookContent.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
        
        // Mouse events for desktop testing
        bookContent.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        bookContent.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        
        // Popup controls
        document.getElementById('editCommentBtn').addEventListener('click', () => this.editComment());
        document.getElementById('deleteHighlightBtn').addEventListener('click', () => this.deleteHighlight());
        
        // Color pills
        document.querySelectorAll('.color-pill').forEach(pill => {
            pill.addEventListener('click', (e) => this.changeHighlightColor(e.target.dataset.color));
        });
        
        // Hide popup when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!this.popup.contains(e.target) && !e.target.closest('.text-highlight')) {
                this.hidePopup();
            }
        });
        
        // Handle text selection changes
        document.addEventListener('selectionchange', () => this.handleSelectionChange());
    }

    handleTouchStart(e) {
        if (e.target.closest('.text-highlight')) return; // Don't interfere with existing highlights
        
        this.touchStartTime = Date.now();
        this.touchStartPos = {
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
        };
    }

    handleTouchEnd(e) {
        if (e.target.closest('.text-highlight')) return;
        
        const touchDuration = Date.now() - this.touchStartTime;
        const currentTime = Date.now();
        const timeSinceLastTap = currentTime - this.lastTapTime;
        
        // Check if this was a quick tap (not a long press or scroll)
        if (touchDuration < 200 && this.touchStartPos) {
            const endPos = e.changedTouches[0];
            const distance = Math.sqrt(
                Math.pow(endPos.clientX - this.touchStartPos.x, 2) + 
                Math.pow(endPos.clientY - this.touchStartPos.y, 2)
            );
            
            // If touch didn't move much, it's a tap
            if (distance < 10) {
                if (timeSinceLastTap < this.tapDelay) {
                    // Double tap - create highlight
                    e.preventDefault();
                    this.handleDoubleTap(e.changedTouches[0]);
                } else {
                    // Single tap - line highlight
                    this.handleSingleTap(e.changedTouches[0]);
                }
                this.lastTapTime = currentTime;
            }
        }
    }

    handleMouseDown(e) {
        if (e.target.closest('.text-highlight')) return;
        this.touchStartTime = Date.now();
        this.touchStartPos = { x: e.clientX, y: e.clientY };
    }

    handleMouseUp(e) {
        if (e.target.closest('.text-highlight')) return;
        
        const clickDuration = Date.now() - this.touchStartTime;
        
        if (clickDuration < 200 && this.touchStartPos) {
            const distance = Math.sqrt(
                Math.pow(e.clientX - this.touchStartPos.x, 2) + 
                Math.pow(e.clientY - this.touchStartPos.y, 2)
            );
            
            if (distance < 10) {
                if (e.detail === 1) {
                    // Single click - line highlight
                    this.handleSingleTap(e);
                } else if (e.detail === 2) {
                    // Double click - create highlight
                    e.preventDefault();
                    this.handleDoubleTap(e);
                }
            }
        }
    }

    handleSingleTap(point) {
        const element = document.elementFromPoint(point.clientX, point.clientY);
        if (!element || !this.isInBookContent(element)) return;
        
        // Find the line element (p, div, etc.)
        let lineElement = element;
        while (lineElement && lineElement.parentNode !== document.getElementById('bookContent')) {
            if (lineElement.matches('p, div, h1, h2, h3, h4, h5, h6, li, blockquote')) {
                break;
            }
            lineElement = lineElement.parentNode;
        }
        
        if (!lineElement) return;
        
        // Remove existing line highlight
        if (this.currentLineHighlight) {
            this.currentLineHighlight.classList.remove('line-highlight');
        }
        
        // Toggle line highlight
        if (this.currentLineHighlight === lineElement) {
            this.currentLineHighlight = null;
        } else {
            lineElement.classList.add('line-highlight');
            this.currentLineHighlight = lineElement;
        }
    }

    handleDoubleTap(point) {
        // Clear any line highlight
        if (this.currentLineHighlight) {
            this.currentLineHighlight.classList.remove('line-highlight');
            this.currentLineHighlight = null;
        }
        
        const selection = window.getSelection();
        
        // If there's already a selection, create highlight from it
        if (selection.rangeCount > 0 && !selection.isCollapsed) {
            this.createHighlightFromSelection();
            return;
        }
        
        // Otherwise, select word at point and create highlight
        const range = this.selectWordAtPoint(point);
        if (range) {
            selection.removeAllRanges();
            selection.addRange(range);
            this.createHighlightFromSelection();
        }
    }

    selectWordAtPoint(point) {
        const element = document.elementFromPoint(point.clientX, point.clientY);
        if (!element || !this.isInBookContent(element)) return null;
        
        // Find the text node
        let textNode = element;
        if (textNode.nodeType !== Node.TEXT_NODE) {
            // If not a text node, find the nearest text node
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            textNode = walker.nextNode();
        }
        
        if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return null;
        
        const text = textNode.textContent;
        const range = document.createRange();
        
        // Create a range for each character to find which one was clicked
        let offset = 0;
        for (let i = 0; i < text.length; i++) {
            range.setStart(textNode, i);
            range.setEnd(textNode, i + 1);
            const rect = range.getBoundingClientRect();
            
            if (point.clientX >= rect.left && point.clientX <= rect.right &&
                point.clientY >= rect.top && point.clientY <= rect.bottom) {
                offset = i;
                break;
            }
        }
        
        // Find word boundaries
        const { start, end } = this.getWordBoundaries(text, offset);
        
        if (start < end) {
            range.setStart(textNode, start);
            range.setEnd(textNode, end);
            return range;
        }
        
        return null;
    }

    getWordBoundaries(text, offset) {
        const wordRegex = /\w/;
        let start = offset;
        let end = offset;

        // Find start of word
        while (start > 0 && wordRegex.test(text[start - 1])) {
            start--;
        }

        // Find end of word
        while (end < text.length && wordRegex.test(text[end])) {
            end++;
        }

        // Ensure we have at least one character
        if (start === end && end < text.length) {
            end++;
        }

        return { start, end };
    }

    handleSelectionChange() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) {
            return;
        }

        const range = selection.getRangeAt(0);
        if (!this.isInBookContent(range.commonAncestorContainer)) {
            return;
        }
    }

    createHighlightFromSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) return;

        const range = selection.getRangeAt(0);
        if (!this.isInBookContent(range.commonAncestorContainer)) return;

        const text = range.toString().trim();
        if (!text) return;

        const highlightId = this.generateHighlightId();
        const highlightData = {
            id: highlightId,
            pageNum: this.bookReader.currentPage,
            color: 'yellow',
            comment: '',
            text: text,
            startPath: this.getNodePath(range.startContainer),
            startOffset: range.startOffset,
            endPath: this.getNodePath(range.endContainer),
            endOffset: range.endOffset
        };

        // Create the highlight element
        const span = document.createElement('span');
        span.className = `text-highlight highlight-${highlightData.color}`;
        span.dataset.highlightId = highlightData.id;
        span.addEventListener('click', (e) => {
            e.stopPropagation();
            this.selectHighlight(highlightData);
        });

        try {
            range.surroundContents(span);
            this.addHighlight(highlightData);
            this.showPopup(highlightData);
        } catch (e) {
            console.warn('Could not create highlight:', e);
        }
        
        selection.removeAllRanges();
    }

    addHighlight(highlightData) {
        const pageNum = highlightData.pageNum;
        if (!this.highlights.has(pageNum)) {
            this.highlights.set(pageNum, []);
        }
        this.highlights.get(pageNum).push(highlightData);
        this.saveHighlights();
    }

    selectHighlight(highlightData) {
        // Clear previous selection
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
        });

        // Select this highlight
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (element) {
            element.classList.add('selected');
            this.selectedHighlight = highlightData;
            this.showPopup(highlightData);
        }
    }

    showPopup(highlightData) {
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (!element) return;

        const rect = element.getBoundingClientRect();
        const popup = this.popup;

        // Update popup content
        const commentDiv = document.getElementById('highlightComment');
        commentDiv.textContent = highlightData.comment || 'Click edit to add a comment';
        
        // Update color pill selection
        document.querySelectorAll('.color-pill').forEach(pill => {
            pill.classList.toggle('selected', pill.dataset.color === highlightData.color);
        });

        // Position popup
        popup.style.display = 'block';
        
        // Wait for display to take effect, then position
        requestAnimationFrame(() => {
            const popupRect = popup.getBoundingClientRect();
            
            // Center horizontally on the highlight
            let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
            
            // Keep popup on screen
            left = Math.max(10, Math.min(left, window.innerWidth - popupRect.width - 10));
            
            // Position above the highlight
            let top = rect.top - popupRect.height - 15;
            
            // If popup would go off top of screen, position below
            if (top < 10) {
                top = rect.bottom + 15;
            }
            
            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
            
            // Add show class for animation
            popup.classList.add('show');
        });
    }

    hidePopup() {
        const popup = this.popup;
        popup.classList.remove('show');
        
        setTimeout(() => {
            popup.style.display = 'none';
        }, 200);
        
        this.selectedHighlight = null;
        this.isEditingComment = false;
        
        // Clear selection
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
        });
        
        // Reset edit button
        document.getElementById('editCommentBtn').textContent = 'Edit';
    }

    editComment() {
        if (!this.selectedHighlight) return;

        const commentDiv = document.getElementById('highlightComment');
        const editBtn = document.getElementById('editCommentBtn');
        
        if (this.isEditingComment) {
            // Save comment
            const input = commentDiv.querySelector('input');
            if (input) {
                this.selectedHighlight.comment = input.value.trim();
                commentDiv.textContent = this.selectedHighlight.comment || 'Click edit to add a comment';
                this.saveHighlights();
            }
            this.isEditingComment = false;
            editBtn.textContent = 'Edit';
        } else {
            // Show input
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'comment-input';
            input.value = this.selectedHighlight.comment || '';
            input.placeholder = 'Add a comment...';
            
            // Handle enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    this.editComment(); // This will save and exit edit mode
                }
            });
            
            commentDiv.innerHTML = '';
            commentDiv.appendChild(input);
            
            // Focus and select text
            setTimeout(() => input.focus(), 50);
            
            this.isEditingComment = true;
            editBtn.textContent = 'Save';
        }
    }

    changeHighlightColor(color) {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            // Remove old color class
            element.classList.remove(`highlight-${this.selectedHighlight.color}`);
            // Add new color class
            element.classList.add(`highlight-${color}`);
            
            this.selectedHighlight.color = color;
            this.saveHighlights();
            
            // Update pill selection
            document.querySelectorAll('.color-pill').forEach(pill => {
                pill.classList.toggle('selected', pill.dataset.color === color);
            });
        }
    }

    deleteHighlight() {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            // Replace highlight span with its text content
            const parent = element.parentNode;
            const textNode = document.createTextNode(element.textContent);
            parent.replaceChild(textNode, element);
            parent.normalize(); // Merge adjacent text nodes
        }

        // Remove from data
        const pageHighlights = this.highlights.get(this.selectedHighlight.pageNum);
        if (pageHighlights) {
            const index = pageHighlights.findIndex(h => h.id === this.selectedHighlight.id);
            if (index !== -1) {
                pageHighlights.splice(index, 1);
            }
        }

        this.saveHighlights();
        this.hidePopup();
    }

    restoreHighlights() {
        const pageHighlights = this.highlights.get(this.bookReader.currentPage);
        if (!pageHighlights || pageHighlights.length === 0) return;

        pageHighlights.forEach(highlightData => {
            try {
                const startNode = this.getNodeByPath(highlightData.startPath);
                const endNode = this.getNodeByPath(highlightData.endPath);
                
                if (!startNode || !endNode) return;

                const range = document.createRange();
                range.setStart(startNode, highlightData.startOffset);
                range.setEnd(endNode, highlightData.endOffset);
                
                // Verify the text matches
                if (range.toString().trim() === highlightData.text.trim()) {
                    const span = document.createElement('span');
                    span.className = `text-highlight highlight-${highlightData.color}`;
                    span.dataset.highlightId = highlightData.id;
                    span.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectHighlight(highlightData);
                    });
                    
                    range.surroundContents(span);
                }
            } catch (e) {
                console.warn('Failed to restore highlight:', highlightData.id, e);
            }
        });
    }

    getNodePath(node) {
        const path = [];
        const bookContent = document.getElementById('bookContent');
        
        while (node && node !== bookContent) {
            const parent = node.parentNode;
            if (parent) {
                const index = Array.from(parent.childNodes).indexOf(node);
                path.unshift({ index, nodeType: node.nodeType });
            }
            node = parent;
        }
        return path;
    }

    getNodeByPath(path) {
        let node = document.getElementById('bookContent');
        
        for (const step of path) {
            if (node && node.childNodes[step.index]) {
                node = node.childNodes[step.index];
                if (node.nodeType !== step.nodeType) {
                    return null; // DOM structure has changed
                }
            } else {
                return null;
            }
        }
        return node;
    }

    isInBookContent(node) {
        const bookContent = document.getElementById('bookContent');
        while (node) {
            if (node === bookContent) return true;
            node = node.parentNode;
        }
        return false;
    }

    generateHighlightId() {
        return 'highlight_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    saveHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        const highlightsData = {};
        
        this.highlights.forEach((highlights, pageNum) => {
            if (highlights.length > 0) {
                highlightsData[pageNum] = highlights;
            }
        });
        
        localStorage.setItem(`highlights_${bookName}`, JSON.stringify(highlightsData));
    }

    loadHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        const saved = localStorage.getItem(`highlights_${bookName}`);
        
        if (saved) {
            try {
                const highlightsData = JSON.parse(saved);
                this.highlights.clear();
                
                Object.entries(highlightsData).forEach(([pageNum, highlights]) => {
                    this.highlights.set(parseInt(pageNum), highlights);
                });
            } catch (e) {
                console.warn('Failed to load highlights:', e);
            }
        }
    }
}

class BookReader {
    constructor() {
        this.currentFile = null;
        this.currentPage = 0;
        this.pages = [];
        this.tocItems = [];
        this.isTransitioning = false;
        this.setupEventListeners();
        this.setupIntersectionObserver();
        this.initializeTheme();
        this.highlightManager = new HighlightManager(this);
    }

    initializeTheme() {
        // Get initial theme from localStorage or system preference
        const isDark = localStorage.getItem('darkMode') === 'true' || 
            (!localStorage.getItem('darkMode') && window.matchMedia('(prefers-color-scheme: dark)').matches);
        
        if (isDark) {
            document.documentElement.classList.add('dark');
        }
        
        // Set up theme toggle
        const toggleButton = document.getElementById('darkModeToggle');
        toggleButton.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('darkMode')) {
                document.documentElement.classList.toggle('dark', e.matches);
            }
        });
    }

    setupIntersectionObserver() {
        const contentWrapper = document.getElementById('contentWrapper');
        let isAtBottom = false;
        let isAtTop = true;

        // Intersection Observer for sentinels
        const options = {
            root: null,
            rootMargin: '0px',
            threshold: 0
        };

        const topObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtTop = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        const bottomObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtBottom = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        topObserver.observe(document.getElementById('topSentinel'));
        bottomObserver.observe(document.getElementById('bottomSentinel'));

        // Add scroll event listener for additional control
        contentWrapper.addEventListener('scroll', () => {
            const atBottom = contentWrapper.scrollHeight - contentWrapper.scrollTop <= contentWrapper.clientHeight + 1;
            if (atBottom !== isAtBottom) {
                isAtBottom = atBottom;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            }
        });
    }

    updateControlsVisibility(isAtTop, isAtBottom) {
        const header = document.getElementById('header');
        const footer = document.getElementById('footer');
        
        // Ensure elements exist
        if (!header || !footer) return;
        
        const updateClasses = (element, shouldBeVisible) => {
            if (shouldBeVisible) {
                element.classList.remove('controls-hidden');
                element.classList.add('controls-visible');
            } else {
                element.classList.remove('controls-visible');
                element.classList.add('controls-hidden');
            }
        };

        // When at top, show both controls
        if (isAtTop) {
            updateClasses(header, true);
            updateClasses(footer, true);
        } else {
            updateClasses(header, false);
            // When not at top, footer visibility depends on bottom position
            updateClasses(footer, isAtBottom);
        }
    }

    setupEventListeners() {
        // Navigation
        document.getElementById('prevButton').addEventListener('click', () => this.prevPage());
        document.getElementById('nextButton').addEventListener('click', () => this.nextPage());
        document.getElementById('tocSelect').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
        window.addEventListener('beforeunload', () => this.saveCurrentState());
    }

    getStoredMetadata() {
        return JSON.parse(localStorage.getItem('bookMetadata') || '{}');
    }

    saveCurrentState() {
        if (!this.currentFile?.name) return;
        const metadata = this.getStoredMetadata();
        const bookName = this.currentFile.name.replace(/\.html$/, '');
        metadata[bookName] = { lastPage: this.currentPage };
        localStorage.setItem('bookMetadata', JSON.stringify(metadata));
    }

    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const content = await file.text();
            this.currentFile = file;
            const bookName = file.name.replace(/\.html$/, '');
            
            document.getElementById('currentBookTitle').textContent = bookName;
            this.parseBook(content);
            
            const metadata = this.getStoredMetadata()[bookName] || {};
            this.currentPage = metadata.lastPage || 0;
            
            this.updateDisplay();
            this.highlightManager.loadHighlights();
            setTimeout(() => {
                this.highlightManager.restoreHighlights();
            }, 100);
            this.scrollToTop();
        } catch (error) {
            alert('Error reading file: ' + error.message);
        }

        event.target.value = '';
    }

    parseBook(content) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        
        const chapters = doc.querySelectorAll('.chapter-loaded');
        this.pages = [];
        this.tocItems = [['Cover', 0]];

        chapters.forEach((chapter) => {
            const titleElem = chapter.querySelector('h1, h2, h3');
            if (titleElem) {
                const title = titleElem.textContent.trim();
                this.tocItems.push([title, this.pages.length]);
            }

            const chapterDiv = document.createElement('div');
            chapterDiv.className = 'chapter-loaded';
            chapterDiv.innerHTML = this.cleanContent(chapter);
            this.pages.push(chapterDiv.outerHTML);
        });

        this.updateTOC();
    }

    cleanContent(element) {
        const clone = element.cloneNode(true);
        
        const cleanup = (node) => {
            if (node.nodeType === 1) { // Element node
                // Remove unnecessary attributes
                ['data-originalfontfamily', 'data-originalfontsize', 
                'data-originalcolor', 'data-originalbg', 'onload', 'onerror']
                    .forEach(attr => {
                        if (node.hasAttribute(attr)) {
                            node.removeAttribute(attr);
                        }
                    });

                // Remove all inline styles that affect colors
                if (node.hasAttribute('style')) {
                    const style = node.getAttribute('style');
                    const newStyle = style
                        .replace(/background-color:[^;]+;?/gi, '')
                        .replace(/color:[^;]+;?/gi, '')
                        .trim();
                    
                    if (newStyle) {
                        node.setAttribute('style', newStyle);
                    } else {
                        node.removeAttribute('style');
                    }
                }
                
                // Process children
                node.childNodes.forEach(cleanup);
            }
        };
        
        cleanup(clone);
        return clone.innerHTML;
    }

    updateTOC() {
        const tocSelect = document.getElementById('tocSelect');
        tocSelect.innerHTML = '<option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>';
        
        this.tocItems.forEach(([title, pageNum]) => {
            const option = document.createElement('option');
            option.value = pageNum;
            option.textContent = title;
            option.className = 'bg-white dark:bg-true-black';
            tocSelect.appendChild(option);
        });
    }

    scrollToTop() {
        const contentWrapper = document.getElementById('contentWrapper');
        
        // Try multiple scroll methods for maximum compatibility
        const scrollMethods = [
            // Method 1: scrollTo with options
            () => contentWrapper.scrollTo({
                top: 0,
                behavior: 'instant',
            }),
            // Method 2: Direct scrollTop assignment
            () => contentWrapper.scrollTop = 0,
            // Method 3: Traditional scrollTo
            () => contentWrapper.scrollTo(0, 0),
            // Method 4: Scroll parent element if exists
            () => contentWrapper.parentElement?.scrollTo(0, 0),
        ];

        // Try all methods
        scrollMethods.forEach(method => {
            try {
                method();
            } catch (e) {
                console.error('Scroll method failed:', e);
            }
        });

        // Double-check scroll position in next frame
        requestAnimationFrame(() => {
            if (contentWrapper.scrollTop !== 0) {
                contentWrapper.scrollTop = 0;
            }
        });
    }

    scrollToBottom() {
        const contentWrapper = document.getElementById('contentWrapper');
        contentWrapper.scrollTo({
            top: contentWrapper.scrollHeight,
            behavior: 'instant'
        });
    }

    prevPage() {
        if (this.currentPage > 0) {
            this.currentPage--;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToBottom();
            });
        }
    }

    nextPage() {
        if (this.currentPage < this.pages.length - 1 && !this.isTransitioning) {
            this.isTransitioning = true;
            this.currentPage++;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.isTransitioning = false;
            });
        }
    }

    goToPage(pageNum) {
        if (pageNum >= 0 && pageNum < this.pages.length) {
            this.currentPage = pageNum;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToTop();
            });
        }
    }

    updateDisplay() {
        if (!this.pages.length) {
            document.getElementById('bookContent').innerHTML = 
                '<div class="chapter-loaded text-center text-gray-400 italic">No book selected</div>';
            return;
        }

        // Clear any line highlights
        if (this.highlightManager.currentLineHighlight) {
            this.highlightManager.currentLineHighlight.classList.remove('line-highlight');
            this.highlightManager.currentLineHighlight = null;
        }

        // Hide popup
        this.highlightManager.hidePopup();

        const contentWrapper = document.getElementById('contentWrapper');
        const oldContent = document.getElementById('bookContent');
        
        // Remove old content
        oldContent.remove();
        
        // Force reflow
        void contentWrapper.offsetHeight;
        
        // Create fresh content container
        const newContent = document.createElement('div');
        newContent.id = 'bookContent';
        newContent.className = 'max-w-3xl mx-auto px-4';
        newContent.innerHTML = this.pages[this.currentPage];
        
        // Add new content
        contentWrapper.insertBefore(newContent, contentWrapper.querySelector('#bottomSentinel'));
        
        // Force another reflow
        void contentWrapper.offsetHeight;
        
        // Update UI elements
        document.getElementById('pageIndicator').textContent = 
            `${this.currentPage + 1} / ${this.pages.length}`;
        
        document.getElementById('prevButton').disabled = (this.currentPage === 0);
        document.getElementById('nextButton').disabled = (this.currentPage === this.pages.length - 1);
        
        document.getElementById('tocSelect').value = this.currentPage;
        
        this.saveCurrentState();

        // Restore highlights after page change
        setTimeout(() => {
            this.highlightManager.restoreHighlights();
        }, 100);
    }
}

// Initialize the book reader when the page loads
window.addEventListener('DOMContentLoaded', () => {
    window.bookReader = new BookReader();
});
</script>
</body>
</html>
