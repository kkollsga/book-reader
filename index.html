<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Book Reader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'true-black': '#000000'
                    }
                }
            }
        }
    </script>
    <style>
        .controls-hidden { opacity: 0; pointer-events: none; }
        .controls-visible { opacity: 1; pointer-events: auto; }
        .nav-controls { transition: opacity 0.2s ease-in-out; }
        
        /* Theme aware content styles */
        .chapter-loaded {
            color: rgb(17, 24, 39) !important; /* text-gray-900 */
            background-color: white !important;
        }
        
        .dark .chapter-loaded {
            color: rgb(243, 244, 246) !important; /* text-gray-100 */
            background-color: black !important;
        }
        
        .chapter-loaded * {
            background-color: inherit !important;
            color: inherit !important;
        }

        /* Highlight and selection styles */
        .text-highlight {
            padding: 2px 4px;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
        }

        .text-highlight.selected {
            outline: 2px solid #3b82f6;
            outline-offset: 1px;
        }

        /* Highlight colors */
        .highlight-yellow { background-color: rgba(254, 240, 138, 0.6); }
        .highlight-green { background-color: rgba(187, 247, 208, 0.6); }
        .highlight-blue { background-color: rgba(191, 219, 254, 0.6); }
        .highlight-pink { background-color: rgba(251, 207, 232, 0.6); }
        .highlight-purple { background-color: rgba(221, 214, 254, 0.6); }
        .highlight-orange { background-color: rgba(253, 186, 116, 0.6); }

        .dark .highlight-yellow { background-color: rgba(254, 240, 138, 0.3); }
        .dark .highlight-green { background-color: rgba(187, 247, 208, 0.3); }
        .dark .highlight-blue { background-color: rgba(191, 219, 254, 0.3); }
        .dark .highlight-pink { background-color: rgba(251, 207, 232, 0.3); }
        .dark .highlight-purple { background-color: rgba(221, 214, 254, 0.3); }
        .dark .highlight-orange { background-color: rgba(253, 186, 116, 0.3); }

        /* Popup menu */
        .highlight-popup {
            position: absolute;
            z-index: 50;
            background: white;
            border: 1px solid rgb(229, 231, 235);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            min-width: 280px;
            user-select: none;
            -webkit-user-select: none;
        }

        .dark .highlight-popup {
            background: rgb(17, 24, 39);
            border-color: rgb(75, 85, 99);
        }

        .color-pills {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .color-pill {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-pill:hover,
        .color-pill.selected {
            border-color: #3b82f6;
            transform: scale(1.1);
        }

        .color-pill.yellow { background-color: rgb(254, 240, 138); }
        .color-pill.green { background-color: rgb(187, 247, 208); }
        .color-pill.blue { background-color: rgb(191, 219, 254); }
        .color-pill.pink { background-color: rgb(251, 207, 232); }
        .color-pill.purple { background-color: rgb(221, 214, 254); }
        .color-pill.orange { background-color: rgb(253, 186, 116); }

        .popup-comment {
            font-size: 14px;
            color: rgb(75, 85, 99);
            margin-bottom: 8px;
            max-height: 60px;
            overflow-y: auto;
        }

        .dark .popup-comment {
            color: rgb(156, 163, 175);
        }

        .popup-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .popup-button {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .edit-button {
            background: rgb(59, 130, 246);
            color: white;
        }

        .edit-button:hover {
            background: rgb(37, 99, 235);
        }

        .delete-button {
            background: rgb(239, 68, 68);
            color: white;
        }

        .delete-button:hover {
            background: rgb(220, 38, 38);
        }

        .comment-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid rgb(209, 213, 219);
            border-radius: 4px;
            font-size: 14px;
            background: white;
            color: rgb(17, 24, 39);
        }

        .dark .comment-input {
            background: rgb(31, 41, 55);
            border-color: rgb(75, 85, 99);
            color: rgb(243, 244, 246);
        }
    </style>
</head>
<body class="bg-white dark:bg-true-black text-gray-900 dark:text-white min-h-screen transition-colors duration-200">
    <div class="min-h-screen flex flex-col">
        <div id="topSentinel" class="absolute top-0 h-1 w-full pointer-events-none"></div>
        
        <div id="header" class="fixed top-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-b border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="titleButton" onclick="document.getElementById('fileInput').click()" 
                        class="text-left hover:text-gray-600 dark:hover:text-gray-300 transition-colors cursor-pointer truncate flex-1">
                    <span id="currentBookTitle" class="text-lg font-medium">Select a Book...</span>
                </button>
                <input type="file" id="fileInput" accept=".html" class="hidden">

                <select id="tocSelect" class="ml-4 bg-transparent focus:outline-none hover:text-gray-600 dark:hover:text-gray-300 dark:text-white focus:text-gray-900 dark:focus:text-white cursor-pointer text-sm min-w-[200px]">
                    <option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>
                </select>

                <button id="darkModeToggle" class="ml-4 p-2 hover:text-gray-600 dark:hover:text-gray-300 transition-colors">
                    <i class="fas fa-moon text-blue-500 dark:hidden"></i>
                    <i class="fas fa-sun text-yellow-500 hidden dark:inline"></i>
                </button>
            </div>
        </div>

        <div id="contentWrapper" class="flex-1 overflow-y-auto bg-white dark:bg-true-black pt-12 pb-12">
            <div id="topSentinel" class="sticky top-0 h-1 w-full pointer-events-none"></div>
            
            <div id="bookContent" class="max-w-3xl mx-auto px-4">
                <div class="chapter-loaded">
                </div>
            </div>
            
            <div id="bottomSentinel" class="sticky bottom-0 h-1 w-full pointer-events-none"></div>
        </div>

        <div id="footer" class="fixed bottom-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-t border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="prevButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    ← Previous
                </button>
                <div id="pageIndicator" class="text-gray-500 dark:text-gray-400 text-sm">Page 0 of 0</div>
                <button id="nextButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    Next →
                </button>
            </div>
        </div>
    </div>

    <!-- Highlight popup menu -->
    <div id="highlightPopup" class="highlight-popup" style="display: none;">
        <div class="color-pills">
            <div class="color-pill yellow" data-color="yellow"></div>
            <div class="color-pill green" data-color="green"></div>
            <div class="color-pill blue" data-color="blue"></div>
            <div class="color-pill pink" data-color="pink"></div>
            <div class="color-pill purple" data-color="purple"></div>
            <div class="color-pill orange" data-color="orange"></div>
        </div>
        <div class="popup-comment" id="highlightComment">Click edit to add a comment</div>
        <div class="popup-controls">
            <button class="popup-button edit-button" id="editCommentBtn">Edit</button>
            <button class="popup-button delete-button" id="deleteHighlightBtn">Delete</button>
        </div>
    </div>

<script>
class HighlightManager {
    constructor(bookReader) {
        this.bookReader = bookReader;
        this.highlights = new Map(); // pageNum -> highlights array
        this.selectedHighlight = null;
        this.popup = document.getElementById('highlightPopup');
        this.lastTap = 0;
        this.tapTimeout = 300; // Double-tap detection window
        this.isEditingComment = false;
        
        this.setupEventListeners();
        this.loadHighlights();
    }

    setupEventListeners() {
        // Touch events for selection
        document.addEventListener('touchend', (e) => this.handleTouch(e));
        document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        
        // Popup controls
        document.getElementById('editCommentBtn').addEventListener('click', () => this.editComment());
        document.getElementById('deleteHighlightBtn').addEventListener('click', () => this.deleteHighlight());
        
        // Color pills
        document.querySelectorAll('.color-pill').forEach(pill => {
            pill.addEventListener('click', (e) => this.changeHighlightColor(e.target.dataset.color));
        });
        
        // Hide popup when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!this.popup.contains(e.target) && !e.target.closest('.text-highlight')) {
                this.hidePopup();
            }
        });
        
        // Handle selection changes
        document.addEventListener('selectionchange', () => this.handleSelectionChange());
    }

    handleTouch(e) {
        const now = Date.now();
        const isDoubleTap = (now - this.lastTap) < this.tapTimeout;
        this.lastTap = now;

        if (isDoubleTap) {
            e.preventDefault();
            this.handleDoubleTap(e);
        }
    }

    handleMouseUp(e) {
        // For desktop testing - treat as double-click
        if (e.detail === 2) {
            this.handleDoubleTap(e);
        }
    }

    handleDoubleTap(e) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return;

        const range = selection.getRangeAt(0);
        if (range.collapsed) {
            // Select word at tap location
            this.selectWordAtPoint(e.touches ? e.touches[0] : e);
        } else {
            // Create highlight from current selection
            this.createHighlightFromSelection();
        }
    }

    selectWordAtPoint(point) {
        const element = document.elementFromPoint(point.clientX, point.clientY);
        if (!element || !this.isInBookContent(element)) return;

        const selection = window.getSelection();
        const range = document.createRange();
        
        // Find word boundaries
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        let textNode = walker.nextNode();
        while (textNode) {
            const rect = this.getTextNodeRect(textNode, point);
            if (rect) {
                const text = textNode.textContent;
                const offset = this.getCharOffsetAtPoint(textNode, point);
                const { start, end } = this.getWordBoundaries(text, offset);
                
                range.setStart(textNode, start);
                range.setEnd(textNode, end);
                
                selection.removeAllRanges();
                selection.addRange(range);
                return;
            }
            textNode = walker.nextNode();
        }
    }

    getTextNodeRect(textNode, point) {
        const range = document.createRange();
        range.selectNodeContents(textNode);
        const rect = range.getBoundingClientRect();
        
        if (point.clientX >= rect.left && point.clientX <= rect.right &&
            point.clientY >= rect.top && point.clientY <= rect.bottom) {
            return rect;
        }
        return null;
    }

    getCharOffsetAtPoint(textNode, point) {
        const text = textNode.textContent;
        const range = document.createRange();
        
        for (let i = 0; i < text.length; i++) {
            range.setStart(textNode, i);
            range.setEnd(textNode, i + 1);
            const rect = range.getBoundingClientRect();
            
            if (point.clientX >= rect.left && point.clientX <= rect.right) {
                return i;
            }
        }
        return 0;
    }

    getWordBoundaries(text, offset) {
        const wordRegex = /\w/;
        let start = offset;
        let end = offset;

        // Find start of word
        while (start > 0 && wordRegex.test(text[start - 1])) {
            start--;
        }

        // Find end of word
        while (end < text.length && wordRegex.test(text[end])) {
            end++;
        }

        return { start, end };
    }

    handleSelectionChange() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) {
            return;
        }

        // Check if selection is in book content
        const range = selection.getRangeAt(0);
        if (!this.isInBookContent(range.commonAncestorContainer)) {
            return;
        }

        // Show selection handles (you can implement visual feedback here)
    }

    createHighlightFromSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) return;

        const range = selection.getRangeAt(0);
        if (!this.isInBookContent(range.commonAncestorContainer)) return;

        const highlightId = this.generateHighlightId();
        const highlightData = {
            id: highlightId,
            pageNum: this.bookReader.currentPage,
            color: 'yellow',
            comment: '',
            range: this.serializeRange(range),
            text: range.toString()
        };

        this.addHighlight(highlightData);
        this.renderHighlight(highlightData, range);
        this.showPopup(highlightData);
        
        selection.removeAllRanges();
    }

    addHighlight(highlightData) {
        const pageNum = highlightData.pageNum;
        if (!this.highlights.has(pageNum)) {
            this.highlights.set(pageNum, []);
        }
        this.highlights.get(pageNum).push(highlightData);
        this.saveHighlights();
    }

    renderHighlight(highlightData, range) {
        const span = document.createElement('span');
        span.className = `text-highlight highlight-${highlightData.color}`;
        span.dataset.highlightId = highlightData.id;
        span.addEventListener('click', (e) => {
            e.stopPropagation();
            this.selectHighlight(highlightData);
        });

        try {
            range.surroundContents(span);
        } catch (e) {
            // Handle complex selections
            const contents = range.extractContents();
            span.appendChild(contents);
            range.insertNode(span);
        }
    }

    selectHighlight(highlightData) {
        // Clear previous selection
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
        });

        // Select this highlight
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (element) {
            element.classList.add('selected');
            this.selectedHighlight = highlightData;
            this.showPopup(highlightData);
        }
    }

    showPopup(highlightData) {
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (!element) return;

        const rect = element.getBoundingClientRect();
        const popup = this.popup;

        // Update popup content
        document.getElementById('highlightComment').textContent = 
            highlightData.comment || 'Click edit to add a comment';
        
        // Update color pill selection
        document.querySelectorAll('.color-pill').forEach(pill => {
            pill.classList.toggle('selected', pill.dataset.color === highlightData.color);
        });

        // Position popup above the highlight
        popup.style.display = 'block';
        const popupRect = popup.getBoundingClientRect();
        
        popup.style.left = Math.max(10, rect.left - (popupRect.width / 2) + (rect.width / 2)) + 'px';
        popup.style.top = (rect.top - popupRect.height - 10) + 'px';

        // Adjust if popup goes off-screen
        if (parseInt(popup.style.top) < 10) {
            popup.style.top = (rect.bottom + 10) + 'px';
        }
    }

    hidePopup() {
        this.popup.style.display = 'none';
        this.selectedHighlight = null;
        this.isEditingComment = false;
        
        // Clear selection
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
        });
    }

    editComment() {
        if (!this.selectedHighlight) return;

        const commentDiv = document.getElementById('highlightComment');
        if (this.isEditingComment) {
            // Save comment
            const input = commentDiv.querySelector('input');
            if (input) {
                this.selectedHighlight.comment = input.value;
                commentDiv.innerHTML = this.selectedHighlight.comment || 'Click edit to add a comment';
                this.saveHighlights();
            }
            this.isEditingComment = false;
            document.getElementById('editCommentBtn').textContent = 'Edit';
        } else {
            // Show input
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'comment-input';
            input.value = this.selectedHighlight.comment || '';
            input.placeholder = 'Add a comment...';
            
            commentDiv.innerHTML = '';
            commentDiv.appendChild(input);
            input.focus();
            
            this.isEditingComment = true;
            document.getElementById('editCommentBtn').textContent = 'Save';
        }
    }

    changeHighlightColor(color) {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            // Remove old color class
            element.className = element.className.replace(/highlight-\w+/, '');
            // Add new color class
            element.classList.add(`highlight-${color}`);
            
            this.selectedHighlight.color = color;
            this.saveHighlights();
            
            // Update pill selection
            document.querySelectorAll('.color-pill').forEach(pill => {
                pill.classList.toggle('selected', pill.dataset.color === color);
            });
        }
    }

    deleteHighlight() {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            // Replace highlight span with its text content
            const parent = element.parentNode;
            parent.replaceChild(document.createTextNode(element.textContent), element);
            parent.normalize(); // Merge adjacent text nodes
        }

        // Remove from data
        const pageHighlights = this.highlights.get(this.selectedHighlight.pageNum);
        if (pageHighlights) {
            const index = pageHighlights.findIndex(h => h.id === this.selectedHighlight.id);
            if (index !== -1) {
                pageHighlights.splice(index, 1);
            }
        }

        this.saveHighlights();
        this.hidePopup();
    }

    restoreHighlights() {
        const pageHighlights = this.highlights.get(this.bookReader.currentPage);
        if (!pageHighlights) return;

        pageHighlights.forEach(highlightData => {
            try {
                const range = this.deserializeRange(highlightData.range);
                if (range) {
                    this.renderHighlight(highlightData, range);
                }
            } catch (e) {
                console.warn('Failed to restore highlight:', e);
            }
        });
    }

    serializeRange(range) {
        // Simple serialization - in production, you'd want more robust range serialization
        return {
            startContainerPath: this.getNodePath(range.startContainer),
            startOffset: range.startOffset,
            endContainerPath: this.getNodePath(range.endContainer),
            endOffset: range.endOffset
        };
    }

    deserializeRange(rangeData) {
        try {
            const startContainer = this.getNodeByPath(rangeData.startContainerPath);
            const endContainer = this.getNodeByPath(rangeData.endContainerPath);
            
            if (!startContainer || !endContainer) return null;

            const range = document.createRange();
            range.setStart(startContainer, rangeData.startOffset);
            range.setEnd(endContainer, rangeData.endOffset);
            return range;
        } catch (e) {
            return null;
        }
    }

    getNodePath(node) {
        const path = [];
        const bookContent = document.getElementById('bookContent');
        
        while (node && node !== bookContent) {
            const parent = node.parentNode;
            if (parent) {
                const index = Array.from(parent.childNodes).indexOf(node);
                path.unshift(index);
            }
            node = parent;
        }
        return path;
    }

    getNodeByPath(path) {
        let node = document.getElementById('bookContent');
        for (const index of path) {
            if (node && node.childNodes[index]) {
                node = node.childNodes[index];
            } else {
                return null;
            }
        }
        return node;
    }

    isInBookContent(node) {
        const bookContent = document.getElementById('bookContent');
        while (node) {
            if (node === bookContent) return true;
            node = node.parentNode;
        }
        return false;
    }

    generateHighlightId() {
        return 'highlight_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    saveHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        const highlightsData = {};
        
        this.highlights.forEach((highlights, pageNum) => {
            highlightsData[pageNum] = highlights;
        });
        
        localStorage.setItem(`highlights_${bookName}`, JSON.stringify(highlightsData));
    }

    loadHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        const saved = localStorage.getItem(`highlights_${bookName}`);
        
        if (saved) {
            try {
                const highlightsData = JSON.parse(saved);
                this.highlights.clear();
                
                Object.entries(highlightsData).forEach(([pageNum, highlights]) => {
                    this.highlights.set(parseInt(pageNum), highlights);
                });
            } catch (e) {
                console.warn('Failed to load highlights:', e);
            }
        }
    }
}

class BookReader {
    constructor() {
        this.currentFile = null;
        this.currentPage = 0;
        this.pages = [];
        this.tocItems = [];
        this.isTransitioning = false;
        this.setupEventListeners();
        this.setupIntersectionObserver();
        this.initializeTheme();
        this.highlightManager = new HighlightManager(this);
    }

    initializeTheme() {
        // Get initial theme from localStorage or system preference
        const isDark = localStorage.getItem('darkMode') === 'true' || 
            (!localStorage.getItem('darkMode') && window.matchMedia('(prefers-color-scheme: dark)').matches);
        
        if (isDark) {
            document.documentElement.classList.add('dark');
        }
        
        // Set up theme toggle
        const toggleButton = document.getElementById('darkModeToggle');
        toggleButton.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('darkMode')) {
                document.documentElement.classList.toggle('dark', e.matches);
            }
        });
    }

    setupIntersectionObserver() {
        const contentWrapper = document.getElementById('contentWrapper');
        let isAtBottom = false;
        let isAtTop = true;

        // Intersection Observer for sentinels
        const options = {
            root: null,
            rootMargin: '0px',
            threshold: 0
        };

        const topObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtTop = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        const bottomObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtBottom = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        topObserver.observe(document.getElementById('topSentinel'));
        bottomObserver.observe(document.getElementById('bottomSentinel'));

        // Add scroll event listener for additional control
        contentWrapper.addEventListener('scroll', () => {
            const atBottom = contentWrapper.scrollHeight - contentWrapper.scrollTop <= contentWrapper.clientHeight + 1;
            if (atBottom !== isAtBottom) {
                isAtBottom = atBottom;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            }
        });
    }

    updateControlsVisibility(isAtTop, isAtBottom) {
        const header = document.getElementById('header');
        const footer = document.getElementById('footer');
        
        // Ensure elements exist
        if (!header || !footer) return;
        
        const updateClasses = (element, shouldBeVisible) => {
            if (shouldBeVisible) {
                element.classList.remove('controls-hidden');
                element.classList.add('controls-visible');
            } else {
                element.classList.remove('controls-visible');
                element.classList.add('controls-hidden');
            }
        };

        // When at top, show both controls
        if (isAtTop) {
            updateClasses(header, true);
            updateClasses(footer, true);
        } else {
            updateClasses(header, false);
            // When not at top, footer visibility depends on bottom position
            updateClasses(footer, isAtBottom);
        }
    }

    setupEventListeners() {
        // Navigation
        document.getElementById('prevButton').addEventListener('click', () => this.prevPage());
        document.getElementById('nextButton').addEventListener('click', () => this.nextPage());
        document.getElementById('tocSelect').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
        window.addEventListener('beforeunload', () => this.saveCurrentState());
    }

    getStoredMetadata() {
        return JSON.parse(localStorage.getItem('bookMetadata') || '{}');
    }

    saveCurrentState() {
        if (!this.currentFile?.name) return;
        const metadata = this.getStoredMetadata();
        const bookName = this.currentFile.name.replace(/\.html$/, '');
        metadata[bookName] = { lastPage: this.currentPage };
        localStorage.setItem('bookMetadata', JSON.stringify(metadata));
    }

    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const content = await file.text();
            this.currentFile = file;
            const bookName = file.name.replace(/\.html$/, '');
            
            document.getElementById('currentBookTitle').textContent = bookName;
            this.parseBook(content);
            
            const metadata = this.getStoredMetadata()[bookName] || {};
            this.currentPage = metadata.lastPage || 0;
            
            this.updateDisplay();
            this.highlightManager.loadHighlights();
            this.highlightManager.restoreHighlights();
            this.scrollToTop();
        } catch (error) {
            alert('Error reading file: ' + error.message);
        }

        event.target.value = '';
    }

    parseBook(content) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        
        const chapters = doc.querySelectorAll('.chapter-loaded');
        this.pages = [];
        this.tocItems = [['Cover', 0]];

        chapters.forEach((chapter) => {
            const titleElem = chapter.querySelector('h1, h2, h3');
            if (titleElem) {
                const title = titleElem.textContent.trim();
                this.tocItems.push([title, this.pages.length]);
            }

            const chapterDiv = document.createElement('div');
            chapterDiv.className = 'chapter-loaded';
            chapterDiv.innerHTML = this.cleanContent(chapter);
            this.pages.push(chapterDiv.outerHTML);
        });

        this.updateTOC();
    }

    cleanContent(element) {
        const clone = element.cloneNode(true);
        
        const cleanup = (node) => {
            if (node.nodeType === 1) { // Element node
                // Remove unnecessary attributes
                ['data-originalfontfamily', 'data-originalfontsize', 
                'data-originalcolor', 'data-originalbg', 'onload', 'onerror']
                    .forEach(attr => {
                        if (node.hasAttribute(attr)) {
                            node.removeAttribute(attr);
                        }
                    });

                // Remove all inline styles that affect colors
                if (node.hasAttribute('style')) {
                    const style = node.getAttribute('style');
                    const newStyle = style
                        .replace(/background-color:[^;]+;?/gi, '')
                        .replace(/color:[^;]+;?/gi, '')
                        .trim();
                    
                    if (newStyle) {
                        node.setAttribute('style', newStyle);
                    } else {
                        node.removeAttribute('style');
                    }
                }
                
                // Process children
                node.childNodes.forEach(cleanup);
            }
        };
        
        cleanup(clone);
        return clone.innerHTML;
    }

    updateTOC() {
        const tocSelect = document.getElementById('tocSelect');
        tocSelect.innerHTML = '<option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>';
        
        this.tocItems.forEach(([title, pageNum]) => {
            const option = document.createElement('option');
            option.value = pageNum;
            option.textContent = title;
            option.className = 'bg-white dark:bg-true-black';
            tocSelect.appendChild(option);
        });
    }

    scrollToTop() {
        const contentWrapper = document.getElementById('contentWrapper');
        
        // Try multiple scroll methods for maximum compatibility
        const scrollMethods = [
            // Method 1: scrollTo with options
            () => contentWrapper.scrollTo({
                top: 0,
                behavior: 'instant',
            }),
            // Method 2: Direct scrollTop assignment
            () => contentWrapper.scrollTop = 0,
            // Method 3: Traditional scrollTo
            () => contentWrapper.scrollTo(0, 0),
            // Method 4: Scroll parent element if exists
            () => contentWrapper.parentElement?.scrollTo(0, 0),
        ];

        // Try all methods
        scrollMethods.forEach(method => {
            try {
                method();
            } catch (e) {
                console.error('Scroll method failed:', e);
            }
        });

        // Double-check scroll position in next frame
        requestAnimationFrame(() => {
            if (contentWrapper.scrollTop !== 0) {
                contentWrapper.scrollTop = 0;
            }
        });
    }

    scrollToBottom() {
        const contentWrapper = document.getElementById('contentWrapper');
        contentWrapper.scrollTo({
            top: contentWrapper.scrollHeight,
            behavior: 'instant'
        });
    }

    prevPage() {
        if (this.currentPage > 0) {
            this.currentPage--;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToBottom();
            });
        }
    }

    nextPage() {
        if (this.currentPage < this.pages.length - 1 && !this.isTransitioning) {
            this.isTransitioning = true;
            this.currentPage++;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.isTransitioning = false;
            });
        }
    }

    goToPage(pageNum) {
        if (pageNum >= 0 && pageNum < this.pages.length) {
            this.currentPage = pageNum;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToTop();
            });
        }
    }

    updateDisplay() {
        if (!this.pages.length) {
            document.getElementById('bookContent').innerHTML = 
                '<div class="chapter-loaded text-center text-gray-400 italic">No book selected</div>';
            return;
        }

        const contentWrapper = document.getElementById('contentWrapper');
        const oldContent = document.getElementById('bookContent');
        
        // Remove old content
        oldContent.remove();
        
        // Force reflow
        void contentWrapper.offsetHeight;
        
        // Create fresh content container
        const newContent = document.createElement('div');
        newContent.id = 'bookContent';
        newContent.className = 'max-w-3xl mx-auto px-4';
        newContent.innerHTML = this.pages[this.currentPage];
        
        // Add new content
        contentWrapper.insertBefore(newContent, contentWrapper.querySelector('#bottomSentinel'));
        
        // Force another reflow
        void contentWrapper.offsetHeight;
        
        // Update UI elements
        document.getElementById('pageIndicator').textContent = 
            `${this.currentPage + 1} / ${this.pages.length}`;
        
        document.getElementById('prevButton').disabled = (this.currentPage === 0);
        document.getElementById('nextButton').disabled = (this.currentPage === this.pages.length - 1);
        
        document.getElementById('tocSelect').value = this.currentPage;
        
        this.saveCurrentState();

        // Restore highlights after page change
        setTimeout(() => {
            this.highlightManager.restoreHighlights();
        }, 50);
    }
}

// Initialize the book reader when the page loads
window.addEventListener('DOMContentLoaded', () => {
    window.bookReader = new BookReader();
});
</script>
</body>
</html>
