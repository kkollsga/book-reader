<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Book Reader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'true-black': '#000000'
                    }
                }
            }
        }
    </script>
    <style>
        /* ========== Base Layout ========== */
        #bookContent { position: relative; }
        .nav-controls { transition: opacity 0.2s ease-in-out; }
        .controls-hidden { opacity: 0; pointer-events: none; }
        .controls-visible { opacity: 1; pointer-events: auto; }
        
        /* ========== Chapter Content ========== */
        .chapter-loaded { color: rgb(17, 24, 39) !important; background-color: white !important; }
        .dark .chapter-loaded { color: rgb(243, 244, 246) !important; background-color: black !important; }
        .chapter-loaded * { background-color: inherit !important; color: inherit !important; }
        
        /* ========== Line Highlighting ========== */
        .line-highlight { position: relative; background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%) !important; border-left: 3px solid rgba(59, 130, 246, 0.6) !important; padding-left: 8px !important; margin-left: -11px !important; z-index: 5 !important; }
        .dark .line-highlight { background: linear-gradient(90deg, rgba(147, 197, 253, 0.2) 0%, rgba(147, 197, 253, 0.1) 100%) !important; border-left-color: rgba(147, 197, 253, 0.7) !important; }
        
        /* ========== Text Highlights - Light Mode ========== */
        .highlight-yellow { background-color: #fef3c7 !important; color: #92400e !important; }
        .highlight-green { background-color: #d1fae5 !important; color: #065f46 !important; }
        .highlight-blue { background-color: #dbeafe !important; color: #1e40af !important; }
        .highlight-pink { background-color: #fce7f3 !important; color: #be185d !important; }
        .highlight-purple { background-color: #e9d5ff !important; color: #7c2d12 !important; }
        .highlight-orange { background-color: #fed7aa !important; color: #c2410c !important; }
        
        /* ========== Text Highlights - Dark Mode ========== */
        .dark .highlight-yellow { background-color: #451a03 !important; color: #fbbf24 !important; }
        .dark .highlight-green { background-color: #064e3b !important; color: #34d399 !important; }
        .dark .highlight-blue { background-color: #1e3a8a !important; color: #60a5fa !important; }
        .dark .highlight-pink { background-color: #831843 !important; color: #f472b6 !important; }
        .dark .highlight-purple { background-color: #581c87 !important; color: #c084fc !important; }
        .dark .highlight-orange { background-color: #9a3412 !important; color: #fb923c !important; }
        
        /* ========== Highlight Selection States ========== */
        .text-highlight.selected { position: relative; z-index: 10; transition: all 0.2s ease; --handle-color: #3b82f6; --handle-color-dark: #1d4ed8; --handle-border: #ffffff; }
        .text-highlight.selected.dragging { opacity: 0.7; }
        .text-highlight.selected.dragging .resize-handle-left, .text-highlight.selected.dragging .resize-handle-right { opacity: 0.3; }
        
        /* ========== Resize Handles ========== */
        .text-highlight.selected .resize-handle-left, .text-highlight.selected .resize-handle-right { position: absolute; width: 20px; height: 24px; background: linear-gradient(135deg, var(--handle-color) 0%, var(--handle-color-dark) 100%); opacity: 1; cursor: ew-resize; z-index: 200; border-radius: 10px; border: 3px solid var(--handle-border); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; min-width: 20px; min-height: 24px; }
        .text-highlight.selected .resize-handle-left { left: -10px; top: -2px; }
        .text-highlight.selected .resize-handle-right { right: -10px; bottom: -2px; }
        .text-highlight.selected .resize-handle-left:hover, .text-highlight.selected .resize-handle-right:hover, .text-highlight.selected .resize-handle-left:active, .text-highlight.selected .resize-handle-right:active { transform: scale(1.15); box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4), 0 4px 8px rgba(0, 0, 0, 0.3); }
        
        /* ========== Mobile/Tablet Resize Handles ========== */
        @media (max-width: 1024px) {
            .text-highlight.selected .resize-handle-left, .text-highlight.selected .resize-handle-right { width: 24px; height: 28px; min-width: 24px; min-height: 28px; border-radius: 12px; }
            .text-highlight.selected .resize-handle-left { left: -12px; top: -4px; }
            .text-highlight.selected .resize-handle-right { right: -12px; bottom: -4px; }
        }
        
        /* ========== Dragging Preview Elements ========== */
        .ghost-handle { position: fixed; width: 24px; height: 40px; background: linear-gradient(135deg, var(--handle-color) 0%, var(--handle-color-dark) 100%); border-radius: 12px; border: 3px solid var(--handle-border); box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 4px 12px rgba(0, 0, 0, 0.3); z-index: 1000; pointer-events: none; opacity: 0.9; transform: translate(-50%, -50%) scale(1.2); transition: opacity 0.2s ease; --handle-color: #3b82f6; --handle-color-dark: #1d4ed8; --handle-border: #ffffff; }
        .ghost-handle.visible { opacity: 0.9; }
        .ghost-handle.hidden { opacity: 0; }
        .selection-preview-segment { position: absolute; pointer-events: none; z-index: 150; background: rgba(59, 130, 246, 0.15); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 2px; opacity: 0; transition: opacity 0.1s ease; transform: translateZ(0); --preview-bg: rgba(59, 130, 246, 0.15); --preview-border: rgba(59, 130, 246, 0.3); background: var(--preview-bg); border-color: var(--preview-border); }
        .selection-preview-segment.visible { opacity: 1; }
        
        /* ========== Main Highlight Popup ========== */
        .highlight-popup { position: fixed; z-index: 1000; background: white; border: 1px solid rgb(229, 231, 235); border-radius: 12px; padding: 16px; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); min-width: 300px; max-width: 350px; user-select: none; -webkit-user-select: none; backdrop-filter: blur(8px); transform: translateY(-10px); opacity: 0; transition: all 0.2s ease; display: none; }
        .highlight-popup.show { transform: translateY(0); opacity: 1; }
        .dark .highlight-popup { background: rgba(17, 24, 39, 0.95); border-color: rgb(75, 85, 99); }
        
        /* ========== Popup Header & Controls ========== */
        .popup-header { position: relative; margin-bottom: 12px; }
        .popup-close { position: absolute; top: -8px; right: -8px; width: 24px; height: 24px; border-radius: 50%; background: rgb(239, 68, 68); color: white; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .popup-close:hover { background: rgb(220, 38, 38); transform: scale(1.1); }
        
        /* ========== Color Pills ========== */
        .color-pills { display: flex; gap: 10px; justify-content: center; }
        .color-pill { width: 28px; height: 28px; border-radius: 50%; border: 3px solid transparent; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .color-pill:hover { border-color: #3b82f6; transform: scale(1.15); }
        .color-pill.selected { border-color: #3b82f6; transform: scale(1.2); box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3); }
        .color-pill.yellow { background-color: #fef3c7; }
        .color-pill.green { background-color: #d1fae5; }
        .color-pill.blue { background-color: #dbeafe; }
        .color-pill.pink { background-color: #fce7f3; }
        .color-pill.purple { background-color: #e9d5ff; }
        .color-pill.orange { background-color: #fed7aa; }
        
        /* ========== Comment Input Section ========== */
        .popup-comment { font-size: 14px; color: rgb(75, 85, 99); margin-top: 12px; padding: 8px 12px; background: transparent; border: 2px dashed rgba(156, 163, 175, 0.3); border-radius: 6px; min-height: 40px; cursor: text; transition: all 0.2s ease; line-height: 1.4; }
        .popup-comment:hover { border-color: rgba(59, 130, 246, 0.5); }
        .popup-comment.editing { border-style: solid; border-color: rgb(59, 130, 246); background: rgb(249, 250, 251); }
        .dark .popup-comment { color: rgb(156, 163, 175); border-color: rgba(156, 163, 175, 0.3); }
        .dark .popup-comment:hover { border-color: rgba(147, 197, 253, 0.5); }
        .dark .popup-comment.editing { border-color: rgb(147, 197, 253); background: rgb(31, 41, 55); }
        .comment-input { width: 100%; background: transparent; border: none; outline: none; font-size: 14px; color: inherit; font-family: inherit; line-height: inherit; resize: none; overflow: hidden; }
        .comment-input::placeholder { color: rgba(156, 163, 175, 0.6); font-style: italic; }
        .dark .comment-input::placeholder { color: rgba(156, 163, 175, 0.5); }
        .comment-input:focus { caret-color: rgb(59, 130, 246); }
        .dark .comment-input:focus { caret-color: rgb(147, 197, 253); }
    </style>
    <!-- Container for dynamically injected book styles -->
    <style id="bookStyles"></style>
</head>
<body class="bg-white dark:bg-true-black text-gray-900 dark:text-white min-h-screen transition-colors duration-200">
    <div class="min-h-screen flex flex-col">
        <div id="topSentinel" class="absolute top-0 h-1 w-full pointer-events-none"></div>
        
        <div id="header" class="fixed top-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-b border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="titleButton" onclick="document.getElementById('fileInput').click()" 
                        class="text-left hover:text-gray-600 dark:hover:text-gray-300 transition-colors cursor-pointer truncate flex-1">
                    <span id="currentBookTitle" class="text-lg font-medium">Select a Book...</span>
                </button>
                <input type="file" id="fileInput" accept=".html" class="hidden">
        
                <select id="tocSelect" class="ml-4 bg-transparent focus:outline-none hover:text-gray-600 dark:hover:text-gray-300 dark:text-white focus:text-gray-900 dark:focus:text-white cursor-pointer text-sm min-w-[200px]">
                    <option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>
                </select>
        
                <div class="ml-4 flex items-center gap-1">
                    <button id="zoomOut" class="p-2 w-10 h-10 flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-800 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fas fa-minus text-sm"></i>
                    </button>
                    <span id="zoomIndicator" class="px-2 text-xs text-gray-500 dark:text-gray-400 min-w-[3rem] text-center">100%</span>
                    <button id="zoomIn" class="p-2 w-10 h-10 flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-800 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fas fa-plus text-sm"></i>
                    </button>
                </div>
        
                <button id="darkModeToggle" class="ml-4 p-2 hover:text-gray-600 dark:hover:text-gray-300 transition-colors">
                    <i class="fas fa-moon text-blue-500 dark:hidden"></i>
                    <i class="fas fa-sun text-yellow-500 hidden dark:inline"></i>
                </button>
            </div>
        </div>

        <div id="contentWrapper" class="flex-1 overflow-y-auto bg-white dark:bg-true-black pt-12 pb-12">
            <div id="topSentinel" class="sticky top-0 h-1 w-full pointer-events-none"></div>
            
            <div id="bookContent" class="max-w-3xl mx-auto px-4">
                <div class="chapter-loaded">
                </div>
            </div>
            
            <div id="bottomSentinel" class="sticky bottom-0 h-1 w-full pointer-events-none"></div>
        </div>

        <div id="footer" class="fixed bottom-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-t border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="prevButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    ← Previous
                </button>
                <div id="pageIndicator" class="text-gray-500 dark:text-gray-400 text-sm">Page 0 of 0</div>
                <button id="nextButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    Next →
                </button>
            </div>
        </div>
    </div>

    <!-- Highlight popup menu -->
    <div id="highlightPopup" class="highlight-popup">
        <div class="relative mb-3">
            <button class="absolute -top-2 -right-2 w-6 h-6 rounded-full bg-red-500 text-white border-0 cursor-pointer flex items-center justify-center text-xs transition-all duration-200 shadow-sm hover:bg-red-600 hover:scale-110" id="deleteHighlightBtn">
                <i class="fas fa-times"></i>
            </button>
            <div class="flex gap-2.5 justify-center">
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="yellow" id="pill-yellow"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="green" id="pill-green"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="blue" id="pill-blue"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="pink" id="pill-pink"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="purple" id="pill-purple"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="orange" id="pill-orange"></div>
            </div>
        </div>
        <div class="popup-comment" id="highlightComment">
            <textarea class="comment-input" placeholder="Tap to add a comment..." rows="1"></textarea>
        </div>
    </div>

<script>
class StyleProcessor {
    constructor() {
        this.styleElement = document.getElementById('bookStyles');
        // Properties that affect coloring and should be removed
        this.colorProperties = [
            'color',
            'background-color',
            'background',
            'border-color',
            'outline-color',
            'text-decoration-color',
            'text-emphasis-color',
            'column-rule-color',
            'caret-color',
            'fill',
            'stroke',
            'stop-color',
            'flood-color',
            'lighting-color'
        ];
    }

    extractAndProcessStyles(doc) {
        const styles = doc.querySelectorAll('style');
        let processedCSS = '';

        styles.forEach(styleTag => {
            const cssText = styleTag.textContent;
            const cleanedCSS = this.processCSS(cssText);
            if (cleanedCSS) {
                processedCSS += cleanedCSS + '\n';
            }
        });

        // Also extract styles from link tags if they reference internal styles
        const inlineStyles = doc.querySelectorAll('style[type="text/css"]');
        inlineStyles.forEach(styleTag => {
            const cssText = styleTag.textContent;
            const cleanedCSS = this.processCSS(cssText);
            if (cleanedCSS && !processedCSS.includes(cleanedCSS)) {
                processedCSS += cleanedCSS + '\n';
            }
        });

        return processedCSS;
    }

    processCSS(cssText) {
        if (!cssText || !cssText.trim()) return '';

        try {
            // Split CSS into rules while preserving media queries and keyframes
            const rules = this.parseCSS(cssText);
            const processedRules = [];

            rules.forEach(rule => {
                if (rule.type === 'media') {
                    // Process media query
                    const processedMedia = this.processMediaQuery(rule);
                    if (processedMedia) {
                        processedRules.push(processedMedia);
                    }
                } else if (rule.type === 'keyframes') {
                    // Keep keyframes as-is but remove color properties
                    const processedKeyframes = this.processKeyframes(rule);
                    if (processedKeyframes) {
                        processedRules.push(processedKeyframes);
                    }
                } else if (rule.type === 'rule') {
                    // Process regular CSS rule
                    const processedRule = this.processRule(rule);
                    if (processedRule) {
                        processedRules.push(processedRule);
                    }
                }
            });

            return processedRules.join('\n');
        } catch (e) {
            console.warn('Failed to process CSS:', e);
            return '';
        }
    }

    parseCSS(cssText) {
        const rules = [];
        let currentPos = 0;

        // Simple CSS parser that handles media queries, keyframes, and regular rules
        const cssString = cssText.trim();
        
        // Regular expression patterns
        const mediaQueryRegex = /@media[^{]+{/g;
        const keyframesRegex = /@(?:keyframes|webkit-keyframes|moz-keyframes)[^{]+{/g;
        const ruleRegex = /([^{}]+){([^}]*)}/g;

        // First, handle special at-rules (media queries and keyframes)
        let processedCSS = cssString;
        
        // Extract media queries
        const mediaMatches = [...cssString.matchAll(/@media[^{]+{[^{}]*(?:{[^}]*}[^{}]*)*}/g)];
        mediaMatches.forEach(match => {
            const mediaContent = match[0];
            const mediaCondition = mediaContent.match(/@media([^{]+){/)[1];
            const innerContent = mediaContent.substring(mediaContent.indexOf('{') + 1, mediaContent.lastIndexOf('}'));
            
            rules.push({
                type: 'media',
                condition: mediaCondition.trim(),
                content: innerContent
            });
            
            processedCSS = processedCSS.replace(mediaContent, '');
        });

        // Extract keyframes
        const keyframesMatches = [...cssString.matchAll(/@(?:keyframes|webkit-keyframes|moz-keyframes)([^{]+){[^{}]*(?:{[^}]*}[^{}]*)*}/g)];
        keyframesMatches.forEach(match => {
            const keyframesContent = match[0];
            const keyframesName = keyframesContent.match(/@(?:keyframes|webkit-keyframes|moz-keyframes)([^{]+){/)[1];
            const innerContent = keyframesContent.substring(keyframesContent.indexOf('{') + 1, keyframesContent.lastIndexOf('}'));
            
            rules.push({
                type: 'keyframes',
                name: keyframesName.trim(),
                content: innerContent
            });
            
            processedCSS = processedCSS.replace(keyframesContent, '');
        });

        // Now process regular rules from the remaining CSS
        let ruleMatch;
        ruleRegex.lastIndex = 0;
        while ((ruleMatch = ruleRegex.exec(processedCSS)) !== null) {
            const selector = ruleMatch[1].trim();
            const declarations = ruleMatch[2].trim();
            
            if (selector && declarations) {
                rules.push({
                    type: 'rule',
                    selector: selector,
                    declarations: declarations
                });
            }
        }

        return rules;
    }

    processRule(rule) {
        const declarations = this.parseDeclarations(rule.declarations);
        const cleanedDeclarations = declarations.filter(decl => {
            const property = decl.property.toLowerCase();
            return !this.colorProperties.some(colorProp => property.includes(colorProp));
        });

        if (cleanedDeclarations.length === 0) {
            return null;
        }

        const declarationsString = cleanedDeclarations
            .map(decl => `${decl.property}: ${decl.value};`)
            .join(' ');

        return `${rule.selector} { ${declarationsString} }`;
    }

    processMediaQuery(rule) {
        const innerRules = this.parseCSS(rule.content);
        const processedInnerRules = [];

        innerRules.forEach(innerRule => {
            if (innerRule.type === 'rule') {
                const processed = this.processRule(innerRule);
                if (processed) {
                    processedInnerRules.push(processed);
                }
            }
        });

        if (processedInnerRules.length === 0) {
            return null;
        }

        return `@media ${rule.condition} {\n${processedInnerRules.join('\n')}\n}`;
    }

    processKeyframes(rule) {
        // Process keyframe content to remove color properties
        const keyframeRules = rule.content.match(/[^{}]+{[^}]*}/g) || [];
        const processedKeyframeRules = [];

        keyframeRules.forEach(keyframeRule => {
            const match = keyframeRule.match(/([^{]+){([^}]*)}/);
            if (match) {
                const selector = match[1].trim();
                const declarations = this.parseDeclarations(match[2]);
                const cleanedDeclarations = declarations.filter(decl => {
                    const property = decl.property.toLowerCase();
                    return !this.colorProperties.some(colorProp => property.includes(colorProp));
                });

                if (cleanedDeclarations.length > 0) {
                    const declarationsString = cleanedDeclarations
                        .map(decl => `${decl.property}: ${decl.value};`)
                        .join(' ');
                    processedKeyframeRules.push(`${selector} { ${declarationsString} }`);
                }
            }
        });

        if (processedKeyframeRules.length === 0) {
            return null;
        }

        return `@keyframes ${rule.name} {\n${processedKeyframeRules.join('\n')}\n}`;
    }

    parseDeclarations(declarationsString) {
        const declarations = [];
        const declArray = declarationsString.split(';');

        declArray.forEach(decl => {
            const colonIndex = decl.indexOf(':');
            if (colonIndex > 0) {
                const property = decl.substring(0, colonIndex).trim();
                const value = decl.substring(colonIndex + 1).trim();
                if (property && value) {
                    declarations.push({ property, value });
                }
            }
        });

        return declarations;
    }

    injectStyles(cssText) {
        if (this.styleElement && cssText) {
            this.styleElement.textContent = cssText;
        }
    }

    clearStyles() {
        if (this.styleElement) {
            this.styleElement.textContent = '';
        }
    }
}

class ZoomManager {
    constructor() {
        this.minZoom = 100;
        this.maxZoom = 200;
        this.zoomStep = 10;
        this.currentZoom = this.loadZoomLevel();
        this.baseMaxWidth = 48; // 48rem = 768px (max-w-3xl)
        this.baseFontSize = 16; // Base font size in pixels
        
        this.setupZoomControls();
        this.applyZoom();
    }
    
    loadZoomLevel() {
        const saved = localStorage.getItem('bookReaderZoom');
        const zoom = saved ? parseInt(saved) : 100;
        return Math.max(this.minZoom, Math.min(this.maxZoom, zoom));
    }
    
    saveZoomLevel() {
        localStorage.setItem('bookReaderZoom', this.currentZoom.toString());
    }
    
    setupZoomControls() {
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomIndicator = document.getElementById('zoomIndicator');
        
        zoomOutBtn.addEventListener('click', () => this.zoomOut());
        zoomInBtn.addEventListener('click', () => this.zoomIn());
        
        // Update initial state
        this.updateZoomControls();
    }
    
    updateZoomControls() {
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomIndicator = document.getElementById('zoomIndicator');
        
        zoomOutBtn.disabled = this.currentZoom <= this.minZoom;
        zoomInBtn.disabled = this.currentZoom >= this.maxZoom;
        
        if (zoomIndicator) {
            zoomIndicator.textContent = `${this.currentZoom}%`;
        }
    }
    
    zoomIn() {
        if (this.currentZoom < this.maxZoom) {
            this.currentZoom = Math.min(this.maxZoom, this.currentZoom + this.zoomStep);
            this.applyZoom();
            this.saveZoomLevel();
            this.updateZoomControls();
        }
    }
    
    zoomOut() {
        if (this.currentZoom > this.minZoom) {
            this.currentZoom = Math.max(this.minZoom, this.currentZoom - this.zoomStep);
            this.applyZoom();
            this.saveZoomLevel();
            this.updateZoomControls();
        }
    }
    
    applyZoom() {
        const zoomRatio = this.currentZoom / 100;
        
        // Calculate new font size
        const newFontSize = this.baseFontSize * zoomRatio;
        
        // Calculate new max width - increases as we zoom to use more screen space
        // At 100% zoom: 48rem (768px)
        // At 200% zoom: ~72rem (1152px) - uses much more of the screen
        const widthMultiplier = 1 + ((zoomRatio - 1) * 0.5); // Grows at half the rate of zoom
        const newMaxWidth = this.baseMaxWidth * widthMultiplier;
        
        // Apply to root for font size scaling
        document.documentElement.style.fontSize = `${newFontSize}px`;
        
        // Apply max-width to content containers
        const containers = document.querySelectorAll('.max-w-3xl');
        containers.forEach(container => {
            container.style.maxWidth = `${newMaxWidth}rem`;
        });
        
        // Also apply to header and footer content
        const headerContent = document.querySelector('#header .max-w-3xl');
        const footerContent = document.querySelector('#footer .max-w-3xl');
        const bookContent = document.getElementById('bookContent');
        
        if (headerContent) headerContent.style.maxWidth = `${newMaxWidth}rem`;
        if (footerContent) footerContent.style.maxWidth = `${newMaxWidth}rem`;
        if (bookContent) bookContent.style.maxWidth = `${newMaxWidth}rem`;
        
        // Dispatch event for other components to respond to zoom changes
        window.dispatchEvent(new CustomEvent('zoomChanged', { detail: { zoom: this.currentZoom } }));
    }
    
    reset() {
        this.currentZoom = 100;
        this.applyZoom();
        this.saveZoomLevel();
        this.updateZoomControls();
    }
}

class HighlightManager {
    constructor(bookReader) {
        this.bookReader = bookReader;
        this.highlights = new Map();
        this.selectedHighlight = null;
        this.selectionMode = null; // null, 'soft', or 'full'
        this.popup = document.getElementById('highlightPopup');
        this.isEditingComment = false;
        this.currentLineHighlight = null;
        
        // Create comment-only popup
        this.createCommentPopup();
        
        // Simplified drag state
        this.dragState = {
            active: false,
            handle: null, // 'left' or 'right'
            element: null,
            highlightId: null,
            highlightData: null,
            originalRange: null,
            currentPreview: null,
            previewElement: null
        };
        
        // Tap handling
        this.lastTapTime = 0;
        this.tapDelay = 300;
        this.singleTapTimer = null;
        
        // Scroll handling
        this.scrollHandler = null;
        
        this.setupEventListeners();
        this.loadHighlights();
        this.updateColorPillColors();
    }

    createCommentPopup() {
        // Create a minimal comment-only popup
        const commentPopup = document.createElement('div');
        commentPopup.id = 'commentOnlyPopup';
        commentPopup.style.cssText = `
            position: fixed;
            z-index: 999;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(229, 231, 235, 0.8);
            border-radius: 8px;
            padding: 10px 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            max-width: 280px;
            min-width: 100px;
            font-size: 14px;
            line-height: 1.5;
            color: #374151;
            backdrop-filter: blur(8px);
            pointer-events: auto;
            cursor: pointer;
            transition: opacity 0.2s ease, transform 0.2s ease;
            opacity: 0;
            transform: translateY(-5px);
            display: none;
        `;
        document.body.appendChild(commentPopup);
        this.commentOnlyPopup = commentPopup;
    }

    setupEventListeners() {
        // Popup controls
        document.getElementById('deleteHighlightBtn').addEventListener('click', () => this.deleteHighlight());
        document.getElementById('highlightComment').addEventListener('click', () => this.startEditing());
        
        document.querySelectorAll('[data-color]').forEach(pill => {
            pill.addEventListener('click', (e) => this.changeHighlightColor(e.target.dataset.color));
        });
        
        document.addEventListener('click', (e) => {
            // Check if clicking on comment-only popup
            if (this.commentOnlyPopup && this.commentOnlyPopup.contains(e.target)) {
                if (this.selectionMode === 'soft' && this.selectedHighlight) {
                    e.stopPropagation();
                    this.enterFullSelectionMode();
                }
                return;
            }
            
            // Check if clicking on highlight
            if (e.target.closest('.text-highlight')) {
                e.stopPropagation();
                return; // Handled in handleClick
            }
            
            // Check if clicking on the full popup
            if (this.popup && this.popup.contains(e.target)) {
                return; // Don't clear selection when interacting with full popup
            }
            
            // Clicking outside everything - clear selection
            this.clearSelection();
        });

        // Unified pointer events for better touch/mouse handling
        document.addEventListener('pointerdown', this.handlePointerDown.bind(this));
        document.addEventListener('pointermove', this.handlePointerMove.bind(this));
        document.addEventListener('pointerup', this.handlePointerUp.bind(this));
        document.addEventListener('pointercancel', this.handlePointerUp.bind(this));
        
        // Scroll event handling for popups
        const contentWrapper = document.getElementById('contentWrapper');
        if (contentWrapper) {
            this.scrollHandler = () => {
                if (this.selectionMode === 'soft' && this.selectedHighlight) {
                    this.repositionCommentPopup();
                } else if (this.selectionMode === 'full' && this.selectedHighlight) {
                    this.repositionFullPopup();
                }
            };
            contentWrapper.addEventListener('scroll', this.scrollHandler);
        }

        this.addContentEventListeners();
    }

    handlePointerDown(e) {
        // Only handle resize if in full selection mode
        if (this.selectionMode !== 'full') return;
        
        // Check if it's a resize handle
        if (e.target.classList.contains('resize-handle-left') || e.target.classList.contains('resize-handle-right')) {
            e.preventDefault();
            e.stopPropagation();
            
            const highlightElement = e.target.closest('.text-highlight');
            if (!highlightElement) return;
            
            const highlightId = highlightElement.dataset.highlightId;
            const highlightData = this.findHighlightById(highlightId);
            if (!highlightData) return;
            
            // Set pointer capture for smooth dragging
            e.target.setPointerCapture(e.pointerId);
            
            // Initialize drag state with highlight data including color
            this.dragState = {
                active: true,
                handle: e.target.classList.contains('resize-handle-left') ? 'left' : 'right',
                element: highlightElement,
                highlightId: highlightId,
                highlightData: highlightData,
                pointerId: e.pointerId,
                originalRange: this.getHighlightRange(highlightData),
                currentPreview: null,
                previewElement: null
            };
            
            // Create preview element with the correct color
            this.createPreviewElement();
            
            // Add visual feedback
            highlightElement.style.opacity = '0.3';
            highlightElement.style.transition = 'opacity 0.2s ease';
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'ew-resize';
        }
    }

    handlePointerMove(e) {
        if (!this.dragState.active) return;
        
        e.preventDefault();
        
        // Direct update without requestAnimationFrame for immediate response
        this.updateHighlightPreview(e.clientX, e.clientY);
    }

    handlePointerUp(e) {
        if (!this.dragState.active) return;
        
        e.preventDefault();
        
        // Release pointer capture
        if (e.target.hasPointerCapture && e.target.hasPointerCapture(e.pointerId)) {
            e.target.releasePointerCapture(e.pointerId);
        }
        
        // Commit the changes
        if (this.dragState.currentPreview) {
            this.commitHighlightResize();
        }
        
        // Clean up preview element with fade out
        if (this.dragState.previewElement) {
            this.dragState.previewElement.style.transition = 'opacity 0.2s ease';
            this.dragState.previewElement.style.opacity = '0';
            setTimeout(() => {
                if (this.dragState.previewElement) {
                    this.dragState.previewElement.remove();
                }
            }, 200);
            this.dragState.previewElement = null;
        }
        
        // Clean up - restore original opacity
        if (this.dragState.element) {
            this.dragState.element.style.opacity = '';
            this.dragState.element.style.transition = '';
        }
        
        document.body.style.userSelect = '';
        document.body.style.cursor = '';
        
        // Reset drag state
        this.dragState = {
            active: false,
            handle: null,
            element: null,
            highlightId: null,
            highlightData: null,
            originalRange: null,
            currentPreview: null,
            previewElement: null
        };
        
        this.saveHighlights();
    }

    createPreviewElement() {
        // Remove any existing preview
        if (this.dragState.previewElement) {
            this.dragState.previewElement.remove();
        }
        
        // Get the highlight's color
        const highlightColor = this.dragState.highlightData ? this.dragState.highlightData.color : 'blue';
        
        // Color configurations for preview
        const colorMap = {
            yellow: { r: 254, g: 243, b: 199, a: 0.4 },
            green: { r: 209, g: 250, b: 229, a: 0.4 },
            blue: { r: 219, g: 234, b: 254, a: 0.4 },
            pink: { r: 252, g: 231, b: 243, a: 0.4 },
            purple: { r: 233, g: 213, b: 255, a: 0.4 },
            orange: { r: 254, g: 215, b: 170, a: 0.4 }
        };
        
        // Dark mode colors
        const darkColorMap = {
            yellow: { r: 69, g: 26, b: 3, a: 0.5 },
            green: { r: 6, g: 78, b: 59, a: 0.5 },
            blue: { r: 30, g: 58, b: 138, a: 0.5 },
            pink: { r: 131, g: 24, b: 67, a: 0.5 },
            purple: { r: 88, g: 28, b: 135, a: 0.5 },
            orange: { r: 154, g: 52, b: 18, a: 0.5 }
        };
        
        const isDark = document.documentElement.classList.contains('dark');
        const colorConfig = (isDark ? darkColorMap : colorMap)[highlightColor] || colorMap.blue;
        
        // Create a container for preview segments
        const preview = document.createElement('div');
        preview.style.position = 'absolute';
        preview.style.left = '0';
        preview.style.top = '0';
        preview.style.width = '100%';
        preview.style.height = '100%';
        preview.style.pointerEvents = 'none';
        preview.style.zIndex = '999';
        preview.className = 'highlight-preview-container';
        
        // Store color config for use in updatePreviewElementPosition
        preview.dataset.highlightColor = highlightColor;
        preview.dataset.colorR = colorConfig.r;
        preview.dataset.colorG = colorConfig.g;
        preview.dataset.colorB = colorConfig.b;
        preview.dataset.colorA = colorConfig.a;
        
        document.getElementById('bookContent').appendChild(preview);
        this.dragState.previewElement = preview;
    }

    updatePreviewElementPosition(range) {
        if (!this.dragState.previewElement || !range) return;
        
        try {
            const rects = range.getClientRects();
            if (rects.length === 0) {
                this.dragState.previewElement.style.display = 'none';
                return;
            }
            
            const bookContent = document.getElementById('bookContent');
            const contentWrapper = document.getElementById('contentWrapper');
            const bookRect = bookContent.getBoundingClientRect();
            
            // Get stored color values
            const r = this.dragState.previewElement.dataset.colorR;
            const g = this.dragState.previewElement.dataset.colorG;
            const b = this.dragState.previewElement.dataset.colorB;
            const a = this.dragState.previewElement.dataset.colorA;
            
            // Get the highlight color for border
            const highlightColor = this.dragState.previewElement.dataset.highlightColor;
            
            // Border colors based on highlight color
            const borderColors = {
                yellow: 'rgba(217, 166, 7, 0.6)',
                green: 'rgba(22, 101, 52, 0.6)',
                blue: 'rgba(59, 130, 246, 0.6)',
                pink: 'rgba(190, 24, 93, 0.6)',
                purple: 'rgba(107, 33, 168, 0.6)',
                orange: 'rgba(194, 65, 12, 0.6)'
            };
            
            const borderColor = borderColors[highlightColor] || borderColors.blue;
            
            // First, hide all existing boxes
            const existingBoxes = this.dragState.previewElement.querySelectorAll('.preview-box');
            const existingCount = existingBoxes.length;
            const newCount = rects.length;
            
            // Hide extras if we have too many
            for (let i = newCount; i < existingCount; i++) {
                existingBoxes[i].style.display = 'none';
            }
            
            // Update or create boxes for each rect
            let boxIndex = 0;
            for (let rect of rects) {
                if (rect.width === 0 || rect.height === 0) continue;
                
                let box;
                if (boxIndex < existingCount) {
                    // Reuse existing box
                    box = existingBoxes[boxIndex];
                    box.style.display = 'block';
                } else {
                    // Create new box
                    box = document.createElement('div');
                    box.className = 'preview-box';
                    box.style.position = 'absolute';
                    box.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a})`;
                    box.style.border = `2px solid ${borderColor}`;
                    box.style.borderRadius = '2px';
                    box.style.pointerEvents = 'none';
                    this.dragState.previewElement.appendChild(box);
                }
                
                // Calculate position relative to bookContent considering scroll
                const scrollTop = contentWrapper ? contentWrapper.scrollTop : 0;
                
                // Position relative to the bookContent container
                box.style.left = (rect.left - bookRect.left) + 'px';
                box.style.top = (rect.top - bookRect.top) + 'px';
                box.style.width = rect.width + 'px';
                box.style.height = rect.height + 'px';
                
                boxIndex++;
            }
            
            // Make sure the preview container is visible
            this.dragState.previewElement.style.display = 'block';
            
        } catch (e) {
            console.warn('Failed to update preview position:', e);
            if (this.dragState.previewElement) {
                this.dragState.previewElement.style.display = 'none';
            }
        }
    }

    updateHighlightPreview(x, y) {
        if (!this.dragState.active || !this.dragState.highlightData) return;
        
        // Find the character position at the pointer location
        const position = this.getCharacterPositionAtPoint(x, y);
        if (!position || position.charIndex < 0) {
            // Hide preview if we can't find a valid position
            if (this.dragState.previewElement) {
                this.dragState.previewElement.style.display = 'none';
            }
            return;
        }
        
        const section = document.getElementById(this.dragState.highlightData.sectionId);
        if (!section) return;
        
        // Calculate new range based on drag handle
        let newStartChar, newEndChar;
        
        if (this.dragState.handle === 'left') {
            newStartChar = position.charIndex;
            newEndChar = this.dragState.highlightData.endChar;
        } else {
            newStartChar = this.dragState.highlightData.startChar;
            newEndChar = position.charIndex;
        }
        
        // Validate range with better bounds checking
        if (newStartChar < 0 || newEndChar < 0 || newStartChar >= newEndChar) {
            if (this.dragState.previewElement) {
                this.dragState.previewElement.style.display = 'none';
            }
            this.dragState.currentPreview = null;
            return;
        }
        
        // Create preview range
        const previewRange = this.createRangeFromCharPositions(section, newStartChar, newEndChar);
        if (!previewRange) {
            if (this.dragState.previewElement) {
                this.dragState.previewElement.style.display = 'none';
            }
            return;
        }
        
        // Store preview for commit
        this.dragState.currentPreview = {
            startChar: newStartChar,
            endChar: newEndChar,
            range: previewRange
        };
        
        // Update visual preview
        this.updatePreviewElementPosition(previewRange);
    }

    commitHighlightResize() {
        if (!this.dragState.currentPreview || !this.dragState.highlightData) return;
        
        const section = document.getElementById(this.dragState.highlightData.sectionId);
        if (!section) return;
        
        try {
            // Remove old highlight
            const oldElement = this.dragState.element;
            if (oldElement && oldElement.parentNode) {
                const textNode = document.createTextNode(oldElement.textContent);
                oldElement.parentNode.replaceChild(textNode, oldElement);
                // Only normalize if parent exists
                if (textNode.parentNode) {
                    textNode.parentNode.normalize();
                }
            }
            
            // Create new highlight with updated range
            const newRange = this.createRangeFromCharPositions(
                section,
                this.dragState.currentPreview.startChar,
                this.dragState.currentPreview.endChar
            );
            
            if (!newRange) {
                console.warn('Failed to create new range for resized highlight');
                return;
            }
            
            const span = document.createElement('span');
            // Ensure we have a valid color
            const color = this.dragState.highlightData.color || 'yellow';
            span.className = `text-highlight highlight-${color} selected`;
            span.dataset.highlightId = this.dragState.highlightData.id;
            
            try {
                // Check if range can be surrounded
                const contents = newRange.extractContents();
                span.appendChild(contents);
                newRange.insertNode(span);
                
                // Update the highlight data
                this.dragState.highlightData.startChar = this.dragState.currentPreview.startChar;
                this.dragState.highlightData.endChar = this.dragState.currentPreview.endChar;
                this.dragState.highlightData.text = span.textContent;
                
                // Re-add handles to the new element
                setTimeout(() => {
                    this.addResizeHandles(span);
                    this.updateHandleColors(span, color);
                }, 10);
                
            } catch (e) {
                console.warn('Failed to apply new highlight:', e);
                // Try to restore the original if something went wrong
                if (contents) {
                    try {
                        newRange.insertNode(contents);
                    } catch (restoreError) {
                        console.warn('Failed to restore content:', restoreError);
                    }
                }
            }
        } catch (e) {
            console.warn('Failed to commit resize:', e);
        }
    }

    getCharacterPositionAtPoint(x, y) {
        // Try native browser API first
        if (document.caretPositionFromPoint) {
            const pos = document.caretPositionFromPoint(x, y);
            if (pos && pos.offsetNode) {
                const node = pos.offsetNode;
                const section = this.findContainingSection(node);
                if (section) {
                    const charIndex = this.getCharPositionInSection(section, node, pos.offset);
                    // Only return if we got a valid index
                    if (charIndex >= 0) {
                        return { node, offset: pos.offset, charIndex, section };
                    }
                }
            }
        }
        
        // Fallback to caretRangeFromPoint
        if (document.caretRangeFromPoint) {
            const range = document.caretRangeFromPoint(x, y);
            if (range) {
                const node = range.startContainer;
                const section = this.findContainingSection(node);
                if (section) {
                    const charIndex = this.getCharPositionInSection(section, node, range.startOffset);
                    // Only return if we got a valid index
                    if (charIndex >= 0) {
                        return { node, offset: range.startOffset, charIndex, section };
                    }
                }
            }
        }
        
        return null;
    }

    getHighlightRange(highlightData) {
        const section = document.getElementById(highlightData.sectionId);
        if (!section) return null;
        
        return this.createRangeFromCharPositions(
            section,
            highlightData.startChar,
            highlightData.endChar
        );
    }

    addResizeHandles(element) {
        // Remove any existing handles
        element.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(h => h.remove());
        
        const leftHandle = document.createElement('div');
        leftHandle.className = 'resize-handle-left';
        leftHandle.style.touchAction = 'none';
        element.appendChild(leftHandle);
        
        const rightHandle = document.createElement('div');
        rightHandle.className = 'resize-handle-right';
        rightHandle.style.touchAction = 'none';
        element.appendChild(rightHandle);
    }

    removeResizeHandles(element) {
        element.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(h => h.remove());
    }

    updateHandleColors(element, colorName) {
        const colorMap = {
            yellow: { r: 217, g: 166, b: 7 },
            green: { r: 22, g: 101, b: 52 },
            blue: { r: 59, g: 130, b: 246 },
            pink: { r: 190, g: 24, b: 93 },
            purple: { r: 107, g: 33, b: 168 },
            orange: { r: 194, g: 65, b: 12 }
        };

        const isDark = document.documentElement.classList.contains('dark');
        let color = colorMap[colorName] || colorMap.blue;
        
        if (isDark) {
            color = {
                r: Math.min(255, color.r + 50),
                g: Math.min(255, color.g + 50),
                b: Math.min(255, color.b + 50)
            };
        }

        const handleColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
        const handleColorDark = `rgb(${Math.max(0, color.r - 30)}, ${Math.max(0, color.g - 30)}, ${Math.max(0, color.b - 30)})`;
        const borderColor = isDark ? '#1f2937' : '#ffffff';

        element.style.setProperty('--handle-color', handleColor);
        element.style.setProperty('--handle-color-dark', handleColorDark);
        element.style.setProperty('--handle-border', borderColor);
    }

    addContentEventListeners() {
        const bookContent = document.getElementById('bookContent');
        
        // Remove old listeners to prevent duplicates
        bookContent.removeEventListener('click', this.boundHandleClick);
        bookContent.removeEventListener('dblclick', this.boundHandleDoubleClick);
        
        // Create bound functions if they don't exist
        if (!this.boundHandleClick) {
            this.boundHandleClick = this.handleClick.bind(this);
        }
        if (!this.boundHandleDoubleClick) {
            this.handleDoubleClickEvent.bind(this);
        }
        
        // Add click listener for single clicks and highlight selection
        bookContent.addEventListener('click', this.boundHandleClick);
        
        // Add native double-click listener for desktop
        bookContent.addEventListener('dblclick', (e) => {
            // Prevent single click timer from firing
            if (this.singleClickTimer) {
                clearTimeout(this.singleClickTimer);
                this.singleClickTimer = null;
            }
            this.handleDoubleClickEvent(e);
        });
    }

    handleClick(e) {
        // Handle clicks on existing highlights
        if (e.target.closest('.text-highlight')) {
            const highlightElement = e.target.closest('.text-highlight');
            const highlightId = highlightElement.dataset.highlightId;
            const highlightData = this.findHighlightById(highlightId);
            
            if (highlightData) {
                // Check if clicking the same highlight that's already selected
                if (this.selectedHighlight && this.selectedHighlight.id === highlightId) {
                    if (this.selectionMode === 'soft') {
                        // Upgrade to full selection
                        this.enterFullSelectionMode();
                    } else if (this.selectionMode === 'full') {
                        // Already in full mode, do nothing
                    } else {
                        // First click - enter soft selection
                        this.enterSoftSelectionMode(highlightData);
                    }
                } else {
                    // Clicking a different highlight - always start with soft selection
                    this.enterSoftSelectionMode(highlightData);
                }
            }
            return;
        }

        if (!this.isInBookContent(e.target)) return;

        // Clear any existing timer
        if (this.singleClickTimer) {
            clearTimeout(this.singleClickTimer);
        }

        // Set a timer for single click - will be cancelled if double-click happens
        this.singleClickTimer = setTimeout(() => {
            this.handleSingleClick(e);
            this.singleClickTimer = null;
        }, 250);
    }
    
    handleDoubleClickEvent(e) {
        if (!this.isInBookContent(e.target)) return;
        
        // Prevent default browser text selection on double-click
        e.preventDefault();
        
        // Clear any single click timer
        if (this.singleClickTimer) {
            clearTimeout(this.singleClickTimer);
            this.singleClickTimer = null;
        }
        
        // Handle the double click to create highlight
        this.handleDoubleClick(e);
    }

    handleSingleClick(e) {
        const elementAtPoint = document.elementFromPoint(e.clientX, e.clientY);
        this.addLineHighlight(elementAtPoint || e.target);
    }

    handleDoubleClick(e) {
        e.preventDefault();
        window.getSelection().removeAllRanges();
        
        const range = this.selectWordAtPoint(e);
        if (range) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            setTimeout(() => {
                this.createHighlightFromSelection();
            }, 10);
        }
    }

    enterSoftSelectionMode(highlightData) {
        this.clearSelection();
        
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (!element) return;
        
        // Add subtle selected style (no handles)
        element.classList.add('selected');
        element.style.boxShadow = '0 0 0 1px rgba(59, 130, 246, 0.3)';
        element.style.transform = 'scale(1.01)';
        
        this.selectedHighlight = highlightData;
        this.selectionMode = 'soft';
        
        // Only show comment popup if there's actually a comment
        if (highlightData.comment && highlightData.comment.trim()) {
            this.showCommentOnlyPopup(highlightData);
        }
    }

    enterFullSelectionMode() {
        if (!this.selectedHighlight) return;
        
        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (!element) return;
        
        // Hide comment-only popup
        this.hideCommentOnlyPopup();
        
        // Update to stronger selection style
        element.style.boxShadow = '0 0 0 2px rgba(59, 130, 246, 0.5), 0 4px 12px rgba(0, 0, 0, 0.1)';
        element.style.transform = 'scale(1.02)';
        
        // Add handles
        this.addResizeHandles(element);
        this.updateHandleColors(element, this.selectedHighlight.color);
        
        // Show full popup
        this.selectionMode = 'full';
        this.showPopup(this.selectedHighlight);
    }

    clearSelection() {
        // Remove all selected classes and handles
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
            el.style.boxShadow = '';
            el.style.transform = '';
            this.removeResizeHandles(el);
        });
        
        // Hide popups
        this.hideCommentOnlyPopup();
        this.hidePopup();
        
        this.selectedHighlight = null;
        this.selectionMode = null;
    }

    showCommentOnlyPopup(highlightData) {
        // Only show if there's a comment
        if (!highlightData.comment || !highlightData.comment.trim()) return;
        
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const popup = this.commentOnlyPopup;
        
        // Store the associated highlight for repositioning
        popup.dataset.highlightId = highlightData.id;
        
        // Update content
        popup.textContent = highlightData.comment;
        popup.style.fontStyle = 'normal';
        
        // Update dark mode styles
        const isDark = document.documentElement.classList.contains('dark');
        if (isDark) {
            popup.style.background = 'rgba(17, 24, 39, 0.95)';
            popup.style.borderColor = 'rgba(75, 85, 99, 0.8)';
            popup.style.color = '#e5e7eb';
        } else {
            popup.style.background = 'rgba(255, 255, 255, 0.95)';
            popup.style.borderColor = 'rgba(229, 231, 235, 0.8)';
            popup.style.color = '#374151';
        }
        
        // Show and position
        popup.style.display = 'block';
        
        requestAnimationFrame(() => {
            const popupRect = popup.getBoundingClientRect();
            
            // Center above the highlight
            let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
            left = Math.max(10, Math.min(left, window.innerWidth - popupRect.width - 10));
            
            let top = rect.top - popupRect.height - 10;
            if (top < 10) {
                top = rect.bottom + 10;
            }
            
            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
            popup.style.opacity = '1';
            popup.style.transform = 'translateY(0)';
        });
    }

    repositionCommentPopup() {
        if (!this.commentOnlyPopup || this.commentOnlyPopup.style.display === 'none') return;
        
        const highlightId = this.commentOnlyPopup.dataset.highlightId;
        if (!highlightId) return;
        
        const element = document.querySelector(`[data-highlight-id="${highlightId}"]`);
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const popup = this.commentOnlyPopup;
        const popupRect = popup.getBoundingClientRect();
        
        // Center above the highlight
        let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
        left = Math.max(10, Math.min(left, window.innerWidth - popupRect.width - 10));
        
        let top = rect.top - popupRect.height - 10;
        if (top < 10) {
            top = rect.bottom + 10;
        }
        
        popup.style.left = left + 'px';
        popup.style.top = top + 'px';
    }

    repositionFullPopup() {
        if (!this.popup || this.popup.style.display === 'none') return;
        if (!this.selectedHighlight) return;
        
        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const popup = this.popup;
        const popupRect = popup.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
        left = Math.max(10, Math.min(left, window.innerWidth - popupRect.width - 10));
        
        let top = rect.top - popupRect.height - 15;
        if (top < 10) {
            top = rect.bottom + 15;
        }
        
        popup.style.left = left + 'px';
        popup.style.top = top + 'px';
    }

    hideCommentOnlyPopup() {
        if (this.commentOnlyPopup && this.commentOnlyPopup.style.display !== 'none') {
            this.commentOnlyPopup.style.opacity = '0';
            this.commentOnlyPopup.style.transform = 'translateY(-5px)';
            setTimeout(() => {
                if (this.commentOnlyPopup) {
                    this.commentOnlyPopup.style.display = 'none';
                    this.commentOnlyPopup.dataset.highlightId = '';
                }
            }, 200);
        }
    }

    showPopup(highlightData) {
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (!element) {
            console.warn('Could not find highlight element for popup');
            return;
        }

        const rect = element.getBoundingClientRect();
        const popup = this.popup;

        const commentDiv = document.getElementById('highlightComment');
        const textarea = commentDiv.querySelector('.comment-input');
        
        const commentText = highlightData.comment || '';
        textarea.value = commentText;
        this.autoResizeTextarea(textarea);
        
        document.querySelectorAll('[data-color]').forEach(pill => {
            const isSelected = pill.dataset.color === highlightData.color;
            if (isSelected) {
                pill.style.borderColor = '#3b82f6';
                pill.style.transform = 'scale(1.2)';
                pill.style.boxShadow = '0 4px 8px rgba(59, 130, 246, 0.3)';
            } else {
                pill.style.borderColor = 'transparent';
                pill.style.transform = 'scale(1)';
                pill.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            }
        });

        popup.style.display = 'block';
        
        requestAnimationFrame(() => {
            const popupRect = popup.getBoundingClientRect();
            
            let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
            left = Math.max(10, Math.min(left, window.innerWidth - popupRect.width - 10));
            
            let top = rect.top - popupRect.height - 15;
            if (top < 10) {
                top = rect.bottom + 15;
            }
            
            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
            popup.classList.add('show');
        });
    }

    hidePopup() {
        const popup = this.popup;
        popup.classList.remove('show');
        
        if (this.selectedHighlight) {
            const textarea = document.querySelector('.comment-input');
            if (textarea) {
                const newComment = textarea.value.trim();
                if (this.selectedHighlight.comment !== newComment) {
                    this.selectedHighlight.comment = newComment;
                    this.saveHighlights();
                }
            }
            
            // Clear inline styles from the highlight element when closing popup
            const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
            if (element) {
                element.style.boxShadow = '';
                element.style.transform = '';
            }
        }
        
        setTimeout(() => {
            popup.style.display = 'none';
        }, 200);
        
        this.isEditingComment = false;
        
        const commentDiv = document.getElementById('highlightComment');
        if (commentDiv) {
            commentDiv.classList.remove('editing');
        }
    }

    startEditing() {
        const commentDiv = document.getElementById('highlightComment');
        const textarea = commentDiv.querySelector('.comment-input');
        
        commentDiv.classList.add('editing');
        textarea.focus();
        
        this.autoResizeTextarea(textarea);
        
        let saveTimeout;
        const debouncedSave = () => {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                if (this.selectedHighlight) {
                    const newComment = textarea.value.trim();
                    if (this.selectedHighlight.comment !== newComment) {
                        this.selectedHighlight.comment = newComment;
                        this.saveHighlights();
                    }
                }
            }, 300);
        };
        
        textarea.removeEventListener('input', this.commentInputHandler);
        textarea.removeEventListener('blur', this.commentBlurHandler);
        
        this.commentInputHandler = () => {
            this.autoResizeTextarea(textarea);
            debouncedSave();
        };
        
        this.commentBlurHandler = () => {
            if (this.selectedHighlight) {
                const newComment = textarea.value.trim();
                if (this.selectedHighlight.comment !== newComment) {
                    this.selectedHighlight.comment = newComment;
                    this.saveHighlights();
                }
            }
        };
        
        textarea.addEventListener('input', this.commentInputHandler);
        textarea.addEventListener('blur', this.commentBlurHandler);
    }

    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        const newHeight = Math.max(20, textarea.scrollHeight);
        textarea.style.height = newHeight + 'px';
        textarea.rows = Math.max(1, Math.ceil(newHeight / 20));
    }

    changeHighlightColor(color) {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            element.classList.remove(`highlight-${this.selectedHighlight.color}`);
            element.classList.add(`highlight-${color}`);
            
            this.selectedHighlight.color = color;
            
            this.updateHandleColors(element, color);
            
            document.querySelectorAll('[data-color]').forEach(pill => {
                const isSelected = pill.dataset.color === color;
                if (isSelected) {
                    pill.style.borderColor = '#3b82f6';
                    pill.style.transform = 'scale(1.2)';
                    pill.style.boxShadow = '0 4px 8px rgba(59, 130, 246, 0.3)';
                } else {
                    pill.style.borderColor = 'transparent';
                    pill.style.transform = 'scale(1)';
                    pill.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                }
            });
            
            this.saveHighlights();
        }
    }

    deleteHighlight() {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            const parent = element.parentNode;
            const textNode = document.createTextNode(element.textContent);
            parent.replaceChild(textNode, element);
            parent.normalize();
        }

        const pageHighlights = this.highlights.get(this.selectedHighlight.pageNum);
        if (pageHighlights) {
            const index = pageHighlights.findIndex(h => h.id === this.selectedHighlight.id);
            if (index !== -1) {
                pageHighlights.splice(index, 1);
            }
        }

        this.saveHighlights();
        this.clearSelection();
    }

    addLineHighlight(element) {
        let lineElement = this.findTextLine(element);
        if (!lineElement) return;
        
        if (this.currentLineHighlight) {
            this.currentLineHighlight.classList.remove('line-highlight');
        }
        
        if (this.currentLineHighlight === lineElement) {
            this.currentLineHighlight = null;
        } else {
            lineElement.classList.add('line-highlight');
            this.currentLineHighlight = lineElement;
        }
        
        this.bookReader.saveCurrentState();
    }

    findTextLine(element) {
        let current = element;
        let bestCandidate = null;
        
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.TEXT_NODE) {
                current = current.parentElement;
                continue;
            }
            
            if (current.matches && current.matches('span, a, em, strong, i, b, small, code, sup, sub')) {
                return current;
            }
            
            if (current.nodeType === Node.ELEMENT_NODE && 
                current.textContent.trim() && 
                current.offsetHeight > 0 && 
                current.offsetHeight < 150) {
                
                if (!bestCandidate || current.offsetHeight < bestCandidate.offsetHeight) {
                    bestCandidate = current;
                }
            }
            
            if (current.matches && current.matches('p, div, h1, h2, h3, h4, h5, h6, li, blockquote')) {
                if (current.offsetHeight < 100) {
                    return current;
                }
                break;
            }
            
            current = current.parentElement;
        }
        
        if (bestCandidate) {
            return bestCandidate;
        }
        
        current = element;
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.ELEMENT_NODE && current.textContent.trim()) {
                return current;
            }
            current = current.parentElement;
        }
        
        return element;
    }

    selectWordAtPoint(e) {
        const textNode = this.getTextNodeAtPoint(e.clientX, e.clientY);
        if (!textNode) return null;

        const text = textNode.textContent;
        const offset = this.getOffsetInTextNode(textNode, e.clientX, e.clientY);
        
        if (offset === -1) return null;

        const { start, end } = this.getWordBoundaries(text, offset);
        
        if (start < end) {
            const range = document.createRange();
            range.setStart(textNode, start);
            range.setEnd(textNode, end);
            return range;
        }
        
        return null;
    }

    getTextNodeAtPoint(x, y) {
        if (document.caretPositionFromPoint) {
            try {
                const position = document.caretPositionFromPoint(x, y);
                if (position && position.offsetNode && position.offsetNode.nodeType === Node.TEXT_NODE) {
                    return position.offsetNode;
                }
            } catch (e) {
                // Fallback to other methods
            }
        }
        
        if (document.caretRangeFromPoint) {
            try {
                const range = document.caretRangeFromPoint(x, y);
                if (range && range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) {
                    return range.startContainer;
                }
            } catch (e) {
                // Fallback to other methods
            }
        }
        
        const element = document.elementFromPoint(x, y);
        if (!element) return null;
        
        if (element.classList.contains('text-highlight')) {
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            const textNode = walker.nextNode();
            if (textNode) return textNode;
        }
        
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            {
                acceptNode: function(node) {
                    return node.textContent.trim().length > 0 ? 
                        NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                }
            },
            false
        );
        
        let bestTextNode = null;
        let bestDistance = Infinity;
        let textNode;
        
        while (textNode = walker.nextNode()) {
            const range = document.createRange();
            range.selectNodeContents(textNode);
            const rect = range.getBoundingClientRect();
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            
            if (distance < bestDistance) {
                bestDistance = distance;
                bestTextNode = textNode;
            }
        }
        
        return bestTextNode;
    }

    getOffsetInTextNode(textNode, x, y) {
        const text = textNode.textContent;
        if (!text) return 0;
        
        const range = document.createRange();
        let bestOffset = 0;
        let bestDistance = Infinity;
        
        for (let i = 0; i <= text.length; i++) {
            try {
                range.setStart(textNode, i);
                range.setEnd(textNode, Math.min(i + 1, text.length));
                
                const rect = range.getBoundingClientRect();
                if (!rect.width && !rect.height) continue;
                
                const charX = rect.left + rect.width / 2;
                const charY = rect.top + rect.height / 2;
                const distance = Math.sqrt(Math.pow(x - charX, 2) + Math.pow(y - charY, 2));
                
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestOffset = i;
                }
            } catch (e) {
                break;
            }
        }
        
        return Math.min(bestOffset, text.length);
    }

    getWordBoundaries(text, offset) {
        const wordRegex = /[\w''-]/;
        let start = offset;
        let end = offset;

        while (start > 0 && wordRegex.test(text[start - 1])) {
            start--;
        }

        while (end < text.length && wordRegex.test(text[end])) {
            end++;
        }

        if (start === end) {
            if (offset < text.length) {
                end = offset + 1;
            } else if (offset > 0) {
                start = offset - 1;
            }
        }

        if (end - start < 1 && start > 0) {
            start = Math.max(0, offset - 1);
            end = Math.min(text.length, offset + 1);
        }

        return { start, end };
    }

    createHighlightFromSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) return;

        const range = selection.getRangeAt(0);
        if (!this.isInBookContent(range.commonAncestorContainer)) return;

        const text = range.toString().trim();
        if (!text) return;

        const section = this.findContainingSection(range.startContainer);
        if (!section || !section.id) {
            console.warn('Could not find section with ID for highlight');
            return;
        }

        const startChar = this.getCharPositionInSection(section, range.startContainer, range.startOffset);
        const endChar = this.getCharPositionInSection(section, range.endContainer, range.endOffset);
        
        if (startChar === -1 || endChar === -1) {
            console.warn('Could not calculate character positions');
            return;
        }

        const highlightId = this.generateHighlightId();
        const highlightData = {
            id: highlightId,
            pageNum: this.bookReader.currentPage,
            sectionId: section.id,
            startChar: startChar,
            endChar: endChar,
            color: 'yellow',
            comment: '',
            text: text
        };

        const span = document.createElement('span');
        span.className = `text-highlight highlight-${highlightData.color}`;
        span.dataset.highlightId = highlightData.id;

        try {
            range.surroundContents(span);
            this.addHighlight(highlightData);
            
            setTimeout(() => {
                // Start with soft selection for new highlights
                this.enterSoftSelectionMode(highlightData);
            }, 50);
            
        } catch (e) {
            console.warn('Could not create highlight:', e);
        }
        
        selection.removeAllRanges();
    }

    findContainingSection(node) {
        let current = node;
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.ELEMENT_NODE && current.id) {
                return current;
            }
            current = current.parentNode;
        }
        return null;
    }

    getCharPositionInSection(section, targetNode, targetOffset) {
        if (!section || !targetNode) return -1;
        
        const walker = document.createTreeWalker(
            section,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let position = 0;
        let textNode;
        
        while (textNode = walker.nextNode()) {
            if (textNode === targetNode) {
                // Ensure offset is within bounds
                const validOffset = Math.max(0, Math.min(targetOffset, textNode.textContent.length));
                return position + validOffset;
            }
            position += textNode.textContent.length;
        }
        
        return -1;
    }

    createRangeFromCharPositions(section, startChar, endChar) {
        // Add validation for negative or invalid positions
        if (startChar < 0 || endChar < 0 || startChar >= endChar) {
            return null;
        }
        
        const walker = document.createTreeWalker(
            section,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let currentPos = 0;
        let textNode;
        let startNode = null, startOffset = 0;
        let endNode = null, endOffset = 0;
        
        while (textNode = walker.nextNode()) {
            const nodeLength = textNode.textContent.length;
            
            if (!startNode && currentPos + nodeLength >= startChar) {
                startNode = textNode;
                startOffset = Math.min(startChar - currentPos, nodeLength);
            }
            
            if (!endNode && currentPos + nodeLength >= endChar) {
                endNode = textNode;
                endOffset = Math.min(endChar - currentPos, nodeLength);
                break;
            }
            
            currentPos += nodeLength;
        }
        
        if (!startNode || !endNode) return null;
        
        // Validate offsets are within bounds
        if (startOffset < 0 || startOffset > startNode.textContent.length ||
            endOffset < 0 || endOffset > endNode.textContent.length) {
            return null;
        }
        
        try {
            const range = document.createRange();
            range.setStart(startNode, startOffset);
            range.setEnd(endNode, endOffset);
            return range;
        } catch (e) {
            console.warn('Failed to create range:', e);
            return null;
        }
    }

    findHighlightById(highlightId) {
        for (const [pageNum, highlights] of this.highlights) {
            const highlight = highlights.find(h => h.id === highlightId);
            if (highlight) return highlight;
        }
        return null;
    }

    addHighlight(highlightData) {
        const pageNum = highlightData.pageNum;
        if (!this.highlights.has(pageNum)) {
            this.highlights.set(pageNum, []);
        }
        this.highlights.get(pageNum).push(highlightData);
        this.saveHighlights();
    }

    restoreHighlights() {
        const pageHighlights = this.highlights.get(this.bookReader.currentPage);
        if (!pageHighlights || pageHighlights.length === 0) return;

        pageHighlights.forEach((highlightData) => {
            if (document.querySelector(`[data-highlight-id="${highlightData.id}"]`)) {
                return;
            }

            try {
                const section = document.getElementById(highlightData.sectionId);
                if (!section) {
                    console.warn(`Section ${highlightData.sectionId} not found for highlight ${highlightData.id}`);
                    return;
                }

                const range = this.createRangeFromCharPositions(section, highlightData.startChar, highlightData.endChar);
                if (!range || range.collapsed) return;

                const span = document.createElement('span');
                span.className = `text-highlight highlight-${highlightData.color}`;
                span.dataset.highlightId = highlightData.id;
                
                try {
                    range.surroundContents(span);
                } catch (e) {
                    // Silently ignore surroundContents errors
                }
                
            } catch (e) {
                console.warn(`Failed to restore highlight ${highlightData.id}:`, e);
            }
        });

        this.addContentEventListeners();
    }

    isInBookContent(node) {
        const bookContent = document.getElementById('bookContent');
        while (node) {
            if (node === bookContent) return true;
            node = node.parentNode;
        }
        return false;
    }

    generateHighlightId() {
        return 'highlight_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    saveHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        
        try {
            const metadata = this.bookReader.getStoredMetadata();
            
            if (!metadata[bookName]) {
                metadata[bookName] = {};
            }
            
            if (!metadata[bookName].pages) {
                metadata[bookName].pages = {};
            }
            
            this.highlights.forEach((highlights, pageNum) => {
                if (highlights.length > 0) {
                    if (!metadata[bookName].pages[pageNum]) {
                        metadata[bookName].pages[pageNum] = {};
                    }
                    metadata[bookName].pages[pageNum].highlights = highlights;
                } else {
                    if (metadata[bookName].pages[pageNum]) {
                        delete metadata[bookName].pages[pageNum].highlights;
                        if (Object.keys(metadata[bookName].pages[pageNum]).length === 0) {
                            delete metadata[bookName].pages[pageNum];
                        }
                    }
                }
            });
            
            localStorage.setItem('bookMetadata', JSON.stringify(metadata));
            
        } catch (e) {
            console.warn('Failed to save highlights to bookMetadata:', e);
        }
    }

    loadHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        
        try {
            const metadata = this.bookReader.getStoredMetadata();
            const bookData = metadata[bookName];
            
            if (bookData && bookData.pages) {
                this.highlights.clear();
                
                Object.entries(bookData.pages).forEach(([pageNum, pageData]) => {
                    if (pageData.highlights && pageData.highlights.length > 0) {
                        this.highlights.set(parseInt(pageNum), pageData.highlights);
                    }
                });
                return;
            }
            
        } catch (e) {
            console.warn('Failed to load highlights:', e);
        }
    }

    updateColorPillColors() {
        const isDark = document.documentElement.classList.contains('dark');
        
        const colors = {
            yellow: isDark ? '#a16207' : '#fef08a',
            green: isDark ? '#166534' : '#86efac', 
            blue: isDark ? '#0c4a6e' : '#7dd3fc',
            pink: isDark ? '#be185d' : '#f9a8d4',
            purple: isDark ? '#6b21a8' : '#c4b5fd',
            orange: isDark ? '#c2410c' : '#fdba74'
        };
        
        Object.entries(colors).forEach(([color, bgColor]) => {
            const pill = document.getElementById(`pill-${color}`);
            if (pill) {
                pill.style.backgroundColor = bgColor;
            }
        });
    }
}

class BookReader {
    constructor() {
        this.currentFile = null;
        this.currentPage = 0;
        this.pages = [];
        this.tocItems = [];
        this.isTransitioning = false;
        this.styleProcessor = new StyleProcessor();
        this.zoomManager = null; // Will be initialized after DOM is ready
        this.setupEventListeners();
        this.setupIntersectionObserver();
        this.initializeTheme();
        this.highlightManager = new HighlightManager(this);
        
        // Initialize zoom manager after a brief delay to ensure DOM is ready
        setTimeout(() => {
            this.zoomManager = new ZoomManager();
        }, 100);
    }

    initializeTheme() {
        const storedTheme = localStorage.getItem('darkMode');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const isDark = storedTheme === 'true' || (!storedTheme && systemPrefersDark);
        
        if (isDark) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        
        const toggleButton = document.getElementById('darkModeToggle');
        toggleButton.addEventListener('click', () => {
            const newDarkMode = !document.documentElement.classList.contains('dark');
            document.documentElement.classList.toggle('dark', newDarkMode);
            localStorage.setItem('darkMode', newDarkMode.toString());
            
            // Update color pills when theme changes
            if (this.highlightManager) {
                this.highlightManager.updateColorPillColors();
            }
        });

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('darkMode')) {
                const newDarkMode = e.matches;
                document.documentElement.classList.toggle('dark', newDarkMode);
                
                // Update color pills when system theme changes
                if (this.highlightManager) {
                    this.highlightManager.updateColorPillColors();
                }
            }
        });
    }

    setupIntersectionObserver() {
        const contentWrapper = document.getElementById('contentWrapper');
        let isAtBottom = false;
        let isAtTop = true;

        const options = {
            root: null,
            rootMargin: '0px',
            threshold: 0
        };

        const topObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtTop = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        const bottomObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtBottom = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        topObserver.observe(document.getElementById('topSentinel'));
        bottomObserver.observe(document.getElementById('bottomSentinel'));

        let scrollSaveTimeout;
        contentWrapper.addEventListener('scroll', () => {
            const atBottom = contentWrapper.scrollHeight - contentWrapper.scrollTop <= contentWrapper.clientHeight + 1;
            if (atBottom !== isAtBottom) {
                isAtBottom = atBottom;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            }
            
            clearTimeout(scrollSaveTimeout);
            scrollSaveTimeout = setTimeout(() => {
                this.saveCurrentState();
            }, 300);
        });
    }

    updateControlsVisibility(isAtTop, isAtBottom) {
        const header = document.getElementById('header');
        const footer = document.getElementById('footer');
        
        if (!header || !footer) return;
        
        const updateClasses = (element, shouldBeVisible) => {
            if (shouldBeVisible) {
                element.classList.remove('controls-hidden');
                element.classList.add('controls-visible');
            } else {
                element.classList.remove('controls-visible');
                element.classList.add('controls-hidden');
            }
        };

        if (isAtTop) {
            updateClasses(header, true);
            updateClasses(footer, true);
        } else {
            updateClasses(header, false);
            updateClasses(footer, isAtBottom);
        }
    }

    setupEventListeners() {
        document.getElementById('prevButton').addEventListener('click', () => this.prevPage());
        document.getElementById('nextButton').addEventListener('click', () => this.nextPage());
        document.getElementById('tocSelect').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
        
        window.addEventListener('beforeunload', () => {
            this.saveCurrentState();
        });
        
        setInterval(() => {
            if (this.currentFile) {
                this.saveCurrentState();
            }
        }, 30000);

        // Add this inside setupEventListeners method
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Plus for zoom in
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
                e.preventDefault();
                if (this.zoomManager) {
                    this.zoomManager.zoomIn();
                }
            }
            // Ctrl/Cmd + Minus for zoom out
            else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                e.preventDefault();
                if (this.zoomManager) {
                    this.zoomManager.zoomOut();
                }
            }
            // Ctrl/Cmd + 0 for reset zoom
            else if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                e.preventDefault();
                if (this.zoomManager) {
                    this.zoomManager.reset();
                }
            }
        });
    }

    getStoredMetadata() {
        try {
            const stored = localStorage.getItem('bookMetadata');
            const metadata = stored ? JSON.parse(stored) : {};
            return metadata;
        } catch (e) {
            console.warn('⚠️ Could not load book metadata:', e);
            return {};
        }
    }

    saveCurrentState() {
        if (!this.currentFile?.name) return;
        
        const metadata = this.getStoredMetadata();
        const bookName = this.currentFile.name.replace(/\.html$/, '');
        
        const contentWrapper = document.getElementById('contentWrapper');
        const scrollTop = contentWrapper ? contentWrapper.scrollTop : 0;
        
        let lineMarkerPath = null;
        if (this.highlightManager.currentLineHighlight) {
            const section = this.highlightManager.findContainingSection(this.highlightManager.currentLineHighlight);
            if (section && section.id) {
                lineMarkerPath = {
                    sectionId: section.id
                };
            }
        }
        
        if (!metadata[bookName]) {
            metadata[bookName] = {};
        }
        
        metadata[bookName].lastPage = this.currentPage;
        metadata[bookName].scrollTop = scrollTop;
        metadata[bookName].lineMarkerPath = lineMarkerPath;
        
        try {
            localStorage.setItem('bookMetadata', JSON.stringify(metadata));
        } catch (e) {
            console.warn('⚠️ Could not save book metadata:', e);
        }
    }

    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const content = await file.text();
            this.currentFile = file;
            const bookName = file.name.replace(/\.html$/, '');
            
            document.getElementById('currentBookTitle').textContent = bookName;
            this.parseBook(content);
            
            if (this.pages.length === 0) {
                throw new Error('No readable content found in the book file');
            }
            
            const savedState = this.getStoredMetadata()[bookName] || {};
            this.currentPage = this.validatePageNumber(savedState.lastPage) ? savedState.lastPage : 0;
            
            this.highlightManager.loadHighlights();
            this.updateDisplay();
            
            await this.restoreBookState(savedState);
            
        } catch (error) {
            console.error('❌ Error loading book:', error);
            alert('Error reading file: ' + error.message);
        }

        event.target.value = '';
    }

    validatePageNumber(pageNum) {
        return pageNum !== undefined && 
               pageNum >= 0 && 
               pageNum < this.pages.length && 
               this.pages.length > 0;
    }

    async restoreBookState(savedState) {
        await this.waitForDOM(200);
        this.highlightManager.restoreHighlights();
        await this.waitForDOM(100);
        
        if (savedState.lineMarkerPath) {
            this.restoreLineMarker(savedState.lineMarkerPath);
        }
        
        await this.restoreScrollPosition(savedState.scrollTop);
    }

    waitForDOM(delay = 100) {
        return new Promise(resolve => {
            setTimeout(resolve, delay);
        });
    }

    restoreLineMarker(lineMarkerPath) {
        try {
            if (!lineMarkerPath || !lineMarkerPath.sectionId) return;
            
            const section = document.getElementById(lineMarkerPath.sectionId);
            if (section) {
                section.classList.add('line-highlight');
                this.highlightManager.currentLineHighlight = section;
            }
        } catch (e) {
            console.warn('⚠️ Error restoring line marker:', e);
        }
    }

    async restoreScrollPosition(scrollTop) {
        if (!scrollTop || scrollTop <= 0) return;
        
        const contentWrapper = document.getElementById('contentWrapper');
        if (!contentWrapper) return;
        
        for (let attempt = 0; attempt < 5; attempt++) {
            await new Promise(resolve => setTimeout(resolve, 50 * (attempt + 1)));
            contentWrapper.scrollTop = scrollTop;
            
            const actualScroll = contentWrapper.scrollTop;
            if (Math.abs(actualScroll - scrollTop) <= 10) {
                return;
            }
        }
    }

    parseBook(content) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        
        // Extract and process styles first
        const processedStyles = this.styleProcessor.extractAndProcessStyles(doc);
        this.styleProcessor.injectStyles(processedStyles);
        
        const chapters = doc.querySelectorAll('.chapter-loaded');
        this.pages = [];
        this.tocItems = [['Cover', 0]];

        if (chapters.length === 0) {
            const body = doc.body;
            if (body && body.textContent.trim()) {
                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-loaded';
                chapterDiv.innerHTML = this.cleanContent(body);
                this.pages.push(chapterDiv.outerHTML);
                this.tocItems.push(['Chapter 1', 0]);
            } else {
                console.warn('⚠️ No valid content found in HTML file');
                this.pages.push('<div class="chapter-loaded"><p>No content found in this book.</p></div>');
            }
        } else {
            chapters.forEach((chapter, index) => {
                const titleElem = chapter.querySelector('h1, h2, h3');
                if (titleElem) {
                    const title = titleElem.textContent.trim();
                    this.tocItems.push([title, this.pages.length]);
                } else {
                    this.tocItems.push([`Chapter ${index + 1}`, this.pages.length]);
                }

                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-loaded';
                chapterDiv.innerHTML = this.cleanContent(chapter);
                this.pages.push(chapterDiv.outerHTML);
            });
        }

        this.updateTOC();
    }

    cleanContent(element) {
        const clone = element.cloneNode(true);
        
        const cleanup = (node) => {
            if (node.nodeType === 1) {
                ['data-originalfontfamily', 'data-originalfontsize', 
                'data-originalcolor', 'data-originalbg', 'onload', 'onerror']
                    .forEach(attr => {
                        if (node.hasAttribute(attr)) {
                            node.removeAttribute(attr);
                        }
                    });

                if (node.hasAttribute('style')) {
                    const style = node.getAttribute('style');
                    const newStyle = style
                        .replace(/background-color:[^;]+;?/gi, '')
                        .replace(/color:[^;]+;?/gi, '')
                        .trim();
                    
                    if (newStyle) {
                        node.setAttribute('style', newStyle);
                    } else {
                        node.removeAttribute('style');
                    }
                }
                
                node.childNodes.forEach(cleanup);
            }
        };
        
        cleanup(clone);
        return clone.innerHTML;
    }

    updateTOC() {
        const tocSelect = document.getElementById('tocSelect');
        tocSelect.innerHTML = '<option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>';
        
        this.tocItems.forEach(([title, pageNum]) => {
            const option = document.createElement('option');
            option.value = pageNum;
            option.textContent = title;
            option.className = 'bg-white dark:bg-true-black';
            tocSelect.appendChild(option);
        });
    }

    scrollToTop() {
        const contentWrapper = document.getElementById('contentWrapper');
        
        const scrollMethods = [
            () => contentWrapper.scrollTo({
                top: 0,
                behavior: 'instant',
            }),
            () => contentWrapper.scrollTop = 0,
            () => contentWrapper.scrollTo(0, 0),
            () => contentWrapper.parentElement?.scrollTo(0, 0),
        ];

        scrollMethods.forEach(method => {
            try {
                method();
            } catch (e) {
                console.error('⚠️ Scroll method failed:', e);
            }
        });

        requestAnimationFrame(() => {
            if (contentWrapper.scrollTop !== 0) {
                contentWrapper.scrollTop = 0;
            }
        });
    }

    scrollToBottom() {
        const contentWrapper = document.getElementById('contentWrapper');
        contentWrapper.scrollTo({
            top: contentWrapper.scrollHeight,
            behavior: 'instant'
        });
    }

    prevPage() {
        if (this.currentPage > 0) {
            this.saveCurrentState();
            this.currentPage--;
            // Clear old styles when changing pages
            this.styleProcessor.clearStyles();
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToBottom();
            });
        }
    }

    nextPage() {
        if (this.currentPage < this.pages.length - 1 && !this.isTransitioning) {
            this.saveCurrentState();
            this.isTransitioning = true;
            this.currentPage++;
            // Clear old styles when changing pages
            this.styleProcessor.clearStyles();
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.isTransitioning = false;
            });
        }
    }

    goToPage(pageNum) {
        if (pageNum >= 0 && pageNum < this.pages.length) {
            this.saveCurrentState();
            this.currentPage = pageNum;
            // Clear old styles when changing pages
            this.styleProcessor.clearStyles();
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToTop();
            });
        }
    }

    updateDisplay() {
        if (!this.pages.length) {
            document.getElementById('bookContent').innerHTML = 
                '<div class="chapter-loaded text-center text-gray-400 italic">No book selected</div>';
            return;
        }

        if (this.highlightManager.currentLineHighlight) {
            this.highlightManager.currentLineHighlight.classList.remove('line-highlight');
            this.highlightManager.currentLineHighlight = null;
        }

        this.highlightManager.hidePopup();

        const contentWrapper = document.getElementById('contentWrapper');
        const oldContent = document.getElementById('bookContent');
        
        oldContent.remove();
        void contentWrapper.offsetHeight;
        
        const newContent = document.createElement('div');
        newContent.id = 'bookContent';
        newContent.className = 'max-w-3xl mx-auto px-4';
        newContent.innerHTML = this.pages[this.currentPage];
        
        contentWrapper.insertBefore(newContent, contentWrapper.querySelector('#bottomSentinel'));
        void contentWrapper.offsetHeight;
        
        document.getElementById('pageIndicator').textContent = 
            `${this.currentPage + 1} / ${this.pages.length}`;
        
        document.getElementById('prevButton').disabled = (this.currentPage === 0);
        document.getElementById('nextButton').disabled = (this.currentPage === this.pages.length - 1);
        
        document.getElementById('tocSelect').value = this.currentPage;
        
        this.highlightManager.addContentEventListeners();

        setTimeout(() => {
            this.highlightManager.restoreHighlights();
        }, 100);
    }
}

window.addEventListener('DOMContentLoaded', () => {
    window.bookReader = new BookReader();
    
    // Listen for zoom changes to adjust any dynamic elements
    window.addEventListener('zoomChanged', (e) => {
        // Re-apply any necessary adjustments after zoom
        // This ensures highlights and other features work correctly
        if (window.bookReader.highlightManager) {
            setTimeout(() => {
                window.bookReader.highlightManager.addContentEventListeners();
            }, 100);
        }
    });
});
</script>
</body>
</html>
