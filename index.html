<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Book Reader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'true-black': '#000000'
                    }
                }
            }
        }
    </script>
    <style>
        .controls-hidden { opacity: 0; pointer-events: none; }
        .controls-visible { opacity: 1; pointer-events: auto; }
        .nav-controls { transition: opacity 0.2s ease-in-out; }
        
        /* Theme aware content styles */
        .chapter-loaded {
            color: rgb(17, 24, 39) !important; /* text-gray-900 */
            background-color: white !important;
        }
        
        .dark .chapter-loaded {
            color: rgb(243, 244, 246) !important; /* text-gray-100 */
            background-color: black !important;
        }
        
        .chapter-loaded * {
            background-color: inherit !important;
            color: inherit !important;
        }

        /* Line highlighting for reading progress */
        .line-highlight {
            position: relative;
            background: linear-gradient(90deg, 
                rgba(59, 130, 246, 0.15) 0%, 
                rgba(59, 130, 246, 0.08) 100%) !important;
            border-left: 3px solid rgba(59, 130, 246, 0.6) !important;
            padding-left: 8px !important;
            margin-left: -11px !important;
            z-index: 5 !important;
        }

        .dark .line-highlight {
            background: linear-gradient(90deg, 
                rgba(147, 197, 253, 0.2) 0%, 
                rgba(147, 197, 253, 0.1) 100%) !important;
            border-left-color: rgba(147, 197, 253, 0.7) !important;
        }

        /* Drag handles for resizing - always visible when selected */
        .text-highlight.selected {
            position: relative;
        }

        .text-highlight.selected .resize-handle-left,
        .text-highlight.selected .resize-handle-right {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 12px; /* Slightly wider for easier touch */
            background: rgba(59, 130, 246, 0.8); /* Blue color, always visible */
            opacity: 1; /* Always fully visible */
            cursor: ew-resize;
            z-index: 100;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Add shadow for better visibility */
            transition: all 0.2s ease;
        }

        .text-highlight.selected .resize-handle-left {
            left: -6px; /* Adjusted for wider handle */
        }

        .text-highlight.selected .resize-handle-right {
            right: -6px; /* Adjusted for wider handle */
        }

        /* Hover effects for desktop (still nice to have) */
        .text-highlight.selected .resize-handle-left:hover,
        .text-highlight.selected .resize-handle-right:hover {
            background: rgba(59, 130, 246, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        /* Dark mode handles */
        .dark .text-highlight.selected .resize-handle-left,
        .dark .text-highlight.selected .resize-handle-right {
            background: rgba(147, 197, 253, 0.8);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .dark .text-highlight.selected .resize-handle-left:hover,
        .dark .text-highlight.selected .resize-handle-right:hover {
            background: rgba(147, 197, 253, 1);
            box-shadow: 0 4px 8px rgba(147, 197, 253, 0.3);
        }

        /* Make handles more touch-friendly on smaller screens */
        @media (max-width: 768px) {
            .text-highlight.selected .resize-handle-left,
            .text-highlight.selected .resize-handle-right {
                width: 16px; /* Even wider on mobile */
                border-radius: 8px;
            }
            
            .text-highlight.selected .resize-handle-left {
                left: -8px;
            }
            
            .text-highlight.selected .resize-handle-right {
                right: -8px;
            }
        }

        /* Light mode highlight colors - solid but subtle */
        .highlight-yellow { 
            background-color: #fef3c7 !important; 
            color: #92400e !important;
        }
        .highlight-green { 
            background-color: #d1fae5 !important; 
            color: #065f46 !important;
        }
        .highlight-blue { 
            background-color: #dbeafe !important; 
            color: #1e40af !important;
        }
        .highlight-pink { 
            background-color: #fce7f3 !important; 
            color: #be185d !important;
        }
        .highlight-purple { 
            background-color: #e9d5ff !important; 
            color: #7c2d12 !important;
        }
        .highlight-orange { 
            background-color: #fed7aa !important; 
            color: #c2410c !important;
        }

        /* Dark mode highlight colors - muted but visible */
        .dark .highlight-yellow { 
            background-color: #451a03 !important; 
            color: #fbbf24 !important;
        }
        .dark .highlight-green { 
            background-color: #064e3b !important; 
            color: #34d399 !important;
        }
        .dark .highlight-blue { 
            background-color: #1e3a8a !important; 
            color: #60a5fa !important;
        }
        .dark .highlight-pink { 
            background-color: #831843 !important; 
            color: #f472b6 !important;
        }
        .dark .highlight-purple { 
            background-color: #581c87 !important; 
            color: #c084fc !important;
        }
        .dark .highlight-orange { 
            background-color: #9a3412 !important; 
            color: #fb923c !important;
        }

        /* Enhanced selection styling that matches the highlight color */
        .text-highlight.selected {
            box-shadow: 
                0 0 0 2px currentColor,
                0 4px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.02);
            z-index: 10;
        }

        .dark .text-highlight.selected {
            box-shadow: 
                0 0 0 2px currentColor,
                0 4px 12px rgba(255, 255, 255, 0.1);
        }

        /* Popup menu */
        .highlight-popup {
            position: fixed;
            z-index: 1000;
            background: white;
            border: 1px solid rgb(229, 231, 235);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            min-width: 300px;
            max-width: 350px;
            user-select: none;
            -webkit-user-select: none;
            backdrop-filter: blur(8px);
            transform: translateY(-10px);
            opacity: 0;
            transition: all 0.2s ease;
            display: none;
        }

        .highlight-popup.show {
            transform: translateY(0);
            opacity: 1;
        }

        .dark .highlight-popup {
            background: rgba(17, 24, 39, 0.95);
            border-color: rgb(75, 85, 99);
        }

        .popup-header {
            position: relative;
            margin-bottom: 12px;
        }

        .popup-close {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgb(239, 68, 68);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .popup-close:hover {
            background: rgb(220, 38, 38);
            transform: scale(1.1);
        }

        .color-pills {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .color-pill {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .color-pill:hover {
            border-color: #3b82f6;
            transform: scale(1.15);
        }

        .color-pill.selected {
            border-color: #3b82f6;
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .color-pill.yellow { background-color: #fef3c7; }
        .color-pill.green { background-color: #d1fae5; }
        .color-pill.blue { background-color: #dbeafe; }
        .color-pill.pink { background-color: #fce7f3; }
        .color-pill.purple { background-color: #e9d5ff; }
        .color-pill.orange { background-color: #fed7aa; }

        .popup-comment {
            font-size: 14px;
            color: rgb(75, 85, 99);
            margin-top: 12px;
            padding: 8px 12px;
            background: transparent;
            border: 2px dashed rgba(156, 163, 175, 0.3);
            border-radius: 6px;
            min-height: 40px;
            cursor: text;
            transition: all 0.2s ease;
            line-height: 1.4;
        }

        .popup-comment:hover {
            border-color: rgba(59, 130, 246, 0.5);
        }

        .popup-comment.editing {
            border-style: solid;
            border-color: rgb(59, 130, 246);
            background: rgb(249, 250, 251);
        }

        .dark .popup-comment {
            color: rgb(156, 163, 175);
            border-color: rgba(156, 163, 175, 0.3);
        }

        .dark .popup-comment:hover {
            border-color: rgba(147, 197, 253, 0.5);
        }

        .dark .popup-comment.editing {
            border-color: rgb(147, 197, 253);
            background: rgb(31, 41, 55);
        }

        .comment-input {
            width: 100%;
            background: transparent;
            border: none;
            outline: none;
            font-size: 14px;
            color: inherit;
            font-family: inherit;
            line-height: inherit;
            resize: none;
            overflow: hidden;
        }

        .comment-input::placeholder {
            color: rgba(156, 163, 175, 0.6);
            font-style: italic;
        }

        .dark .comment-input::placeholder {
            color: rgba(156, 163, 175, 0.5);
        }

        .comment-input:focus {
            caret-color: rgb(59, 130, 246);
        }

        .dark .comment-input:focus {
            caret-color: rgb(147, 197, 253);
        }
    </style>
</head>
<body class="bg-white dark:bg-true-black text-gray-900 dark:text-white min-h-screen transition-colors duration-200">
    <div class="min-h-screen flex flex-col">
        <div id="topSentinel" class="absolute top-0 h-1 w-full pointer-events-none"></div>
        
        <div id="header" class="fixed top-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-b border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="titleButton" onclick="document.getElementById('fileInput').click()" 
                        class="text-left hover:text-gray-600 dark:hover:text-gray-300 transition-colors cursor-pointer truncate flex-1">
                    <span id="currentBookTitle" class="text-lg font-medium">Select a Book...</span>
                </button>
                <input type="file" id="fileInput" accept=".html" class="hidden">

                <select id="tocSelect" class="ml-4 bg-transparent focus:outline-none hover:text-gray-600 dark:hover:text-gray-300 dark:text-white focus:text-gray-900 dark:focus:text-white cursor-pointer text-sm min-w-[200px]">
                    <option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>
                </select>

                <button id="darkModeToggle" class="ml-4 p-2 hover:text-gray-600 dark:hover:text-gray-300 transition-colors">
                    <i class="fas fa-moon text-blue-500 dark:hidden"></i>
                    <i class="fas fa-sun text-yellow-500 hidden dark:inline"></i>
                </button>
            </div>
        </div>

        <div id="contentWrapper" class="flex-1 overflow-y-auto bg-white dark:bg-true-black pt-12 pb-12">
            <div id="topSentinel" class="sticky top-0 h-1 w-full pointer-events-none"></div>
            
            <div id="bookContent" class="max-w-3xl mx-auto px-4">
                <div class="chapter-loaded">
                </div>
            </div>
            
            <div id="bottomSentinel" class="sticky bottom-0 h-1 w-full pointer-events-none"></div>
        </div>

        <div id="footer" class="fixed bottom-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-t border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="prevButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    ← Previous
                </button>
                <div id="pageIndicator" class="text-gray-500 dark:text-gray-400 text-sm">Page 0 of 0</div>
                <button id="nextButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    Next →
                </button>
            </div>
        </div>
    </div>

    <!-- Highlight popup menu -->
    <div id="highlightPopup" class="highlight-popup">
        <div class="relative mb-3">
            <button class="absolute -top-2 -right-2 w-6 h-6 rounded-full bg-red-500 text-white border-0 cursor-pointer flex items-center justify-center text-xs transition-all duration-200 shadow-sm hover:bg-red-600 hover:scale-110" id="deleteHighlightBtn">
                <i class="fas fa-times"></i>
            </button>
            <div class="flex gap-2.5 justify-center">
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="yellow" id="pill-yellow"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="green" id="pill-green"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="blue" id="pill-blue"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="pink" id="pill-pink"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="purple" id="pill-purple"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="orange" id="pill-orange"></div>
            </div>
        </div>
        <div class="popup-comment" id="highlightComment">
            <textarea class="comment-input" placeholder="Tap to add a comment..." rows="1"></textarea>
        </div>
    </div>

<script>
class HighlightManager {
    constructor(bookReader) {
        this.bookReader = bookReader;
        this.highlights = new Map();
        this.selectedHighlight = null;
        this.popup = document.getElementById('highlightPopup');
        this.isEditingComment = false;
        this.currentLineHighlight = null;
        this.isResizing = false;
        this.resizeHandle = null;
        
        this.lastTapTime = 0;
        this.tapDelay = 300;
        this.singleTapTimer = null;
        
        // Resize capture data
        this.capturedSectionId = null;
        this.capturedStartChar = null;
        this.capturedEndChar = null;
        
        this.handleClick = this.handleClick.bind(this);
        this.handleMouseDown = this.handleMouseDown.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        
        this.setupEventListeners();
        this.loadHighlights();
        this.updateColorPillColors();
    }

    setupEventListeners() {
        document.getElementById('deleteHighlightBtn').addEventListener('click', () => this.deleteHighlight());
        document.getElementById('highlightComment').addEventListener('click', () => this.startEditing());
        
        document.querySelectorAll('[data-color]').forEach(pill => {
            pill.addEventListener('click', (e) => this.changeHighlightColor(e.target.dataset.color));
        });
        
        document.addEventListener('click', (e) => {
            if (!this.popup.contains(e.target) && !e.target.closest('.text-highlight')) {
                this.hidePopup();
            }
        });

        // Mouse events
        document.addEventListener('mousedown', this.handleMouseDown);
        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
        
        // Touch events
        document.addEventListener('touchstart', this.handleTouchStart.bind(this));
        document.addEventListener('touchmove', this.handleTouchMove.bind(this));
        document.addEventListener('touchend', this.handleTouchEnd.bind(this));

        this.addContentEventListeners();
    }

    updateColorPillColors() {
        const isDark = document.documentElement.classList.contains('dark');
        
        const colors = {
            yellow: isDark ? '#a16207' : '#fef08a',
            green: isDark ? '#166534' : '#86efac', 
            blue: isDark ? '#0c4a6e' : '#7dd3fc',
            pink: isDark ? '#be185d' : '#f9a8d4',
            purple: isDark ? '#6b21a8' : '#c4b5fd',
            orange: isDark ? '#c2410c' : '#fdba74'
        };
        
        Object.entries(colors).forEach(([color, bgColor]) => {
            const pill = document.getElementById(`pill-${color}`);
            if (pill) {
                pill.style.backgroundColor = bgColor;
            }
        });
    }

    addContentEventListeners() {
        const bookContent = document.getElementById('bookContent');
        bookContent.removeEventListener('click', this.handleClick);
        bookContent.addEventListener('click', this.handleClick);
    }

    getEventCoordinates(e) {
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
    }

    handleTouchStart(e) {
        if (e.target.classList.contains('resize-handle-left') || e.target.classList.contains('resize-handle-right')) {
            e.preventDefault();
            e.stopPropagation();
            
            this.isResizing = true;
            this.resizeHandle = e.target.classList.contains('resize-handle-left') ? 'left' : 'right';
            this.resizingHighlight = e.target.closest('.text-highlight.selected');
            
            if (!this.resizingHighlight) return;
            
            // Capture current highlight position data
            const highlightData = this.selectedHighlight;
            this.capturedSectionId = highlightData.sectionId;
            this.capturedStartChar = highlightData.startChar;
            this.capturedEndChar = highlightData.endChar;
            
            document.body.style.userSelect = 'none';
            
            // Prevent scrolling during resize
            document.body.style.overflow = 'hidden';
        }
    }

    handleTouchMove(e) {
        if (this.isResizing && this.resizingHighlight) {
            e.preventDefault();
            e.stopPropagation();
            
            const coords = this.getEventCoordinates(e);
            this.updateHighlightSelectionWithCoords(coords.x, coords.y);
        }
    }

    handleTouchEnd(e) {
        if (this.isResizing) {
            this.isResizing = false;
            this.resizeHandle = null;
            this.resizingHighlight = null;
            
            // Clean up captured data
            this.capturedSectionId = null;
            this.capturedStartChar = null;
            this.capturedEndChar = null;
            
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            document.body.style.overflow = '';
            
            this.saveHighlights();
        }
    }

    handleMouseDown(e) {
        if (e.target.classList.contains('resize-handle-left') || e.target.classList.contains('resize-handle-right')) {
            e.preventDefault();
            e.stopPropagation();
            
            this.isResizing = true;
            this.resizeHandle = e.target.classList.contains('resize-handle-left') ? 'left' : 'right';
            this.resizingHighlight = e.target.closest('.text-highlight.selected');
            
            if (!this.resizingHighlight) return;
            
            // Capture current highlight position data
            const highlightData = this.selectedHighlight;
            this.capturedSectionId = highlightData.sectionId;
            this.capturedStartChar = highlightData.startChar;
            this.capturedEndChar = highlightData.endChar;
            
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
        }
    }

    handleMouseMove(e) {
        if (this.isResizing && this.resizingHighlight) {
            e.preventDefault();
            e.stopPropagation();
            
            const coords = this.getEventCoordinates(e);
            this.updateHighlightSelectionWithCoords(coords.x, coords.y);
        } else {
            if (e.target.classList.contains('resize-handle-left') || e.target.classList.contains('resize-handle-right')) {
                document.body.style.cursor = 'ew-resize';
            } else if (!this.isResizing) {
                document.body.style.cursor = '';
            }
        }
    }

    handleMouseUp(e) {
        if (this.isResizing) {
            this.isResizing = false;
            this.resizeHandle = null;
            this.resizingHighlight = null;
            
            // Clean up captured data
            this.capturedSectionId = null;
            this.capturedStartChar = null;
            this.capturedEndChar = null;
            
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            this.saveHighlights();
        }
    }

    updateHighlightSelectionWithCoords(x, y) {
        if (!this.selectedHighlight || !this.resizingHighlight) return;

        const textNode = this.getTextNodeAtPoint(x, y);
        if (!textNode) return;

        const offset = this.getOffsetInTextNode(textNode, x, y);
        
        try {
            const section = document.getElementById(this.capturedSectionId);
            if (!section) return;
            
            const clickPosition = this.getCharPositionInSection(section, textNode, offset);
            if (clickPosition === -1) return;
            
            let newStart, newEnd;
            
            if (this.resizeHandle === 'left') {
                newStart = clickPosition;
                newEnd = this.capturedEndChar;
            } else {
                newStart = this.capturedStartChar;
                newEnd = clickPosition;
            }
            
            if (newStart >= newEnd) return; // Invalid range
            
            const sectionText = section.textContent;
            const newText = sectionText.substring(newStart, newEnd);
            if (!newText.trim()) return;
            
            // Remove old highlight
            const parent = this.resizingHighlight.parentNode;
            if (parent) {
                parent.replaceChild(document.createTextNode(this.resizingHighlight.textContent), this.resizingHighlight);
                parent.normalize();
            }
            
            // Create new highlight
            const newRange = this.createRangeFromCharPositions(section, newStart, newEnd);
            if (!newRange) return;
            
            const span = document.createElement('span');
            span.className = `text-highlight highlight-${this.selectedHighlight.color} selected`;
            span.dataset.highlightId = this.selectedHighlight.id;
            
            try {
                newRange.surroundContents(span);
            } catch (e) {
                // Silently ignore surroundContents errors
            }
            
            // Update stored data
            this.selectedHighlight.startChar = newStart;
            this.selectedHighlight.endChar = newEnd;
            this.selectedHighlight.text = newText;
            
            this.resizingHighlight = span;
            setTimeout(() => this.addSmartResizeHandles(span), 10);
            
        } catch (err) {
            console.warn('Resize failed:', err);
        }
    }

    updateHighlightSelection(e) {
        const coords = this.getEventCoordinates(e);
        this.updateHighlightSelectionWithCoords(coords.x, coords.y);
    }

    handleClick(e) {
        if (e.target.closest('.text-highlight')) {
            const highlightElement = e.target.closest('.text-highlight');
            const highlightId = highlightElement.dataset.highlightId;
            const highlightData = this.findHighlightById(highlightId);
            if (highlightData) {
                this.selectHighlight(highlightData);
            }
            return;
        }

        if (!this.isInBookContent(e.target)) return;

        const now = Date.now();
        const timeSinceLastTap = now - this.lastTapTime;

        if (timeSinceLastTap < this.tapDelay) {
            if (this.singleTapTimer) {
                clearTimeout(this.singleTapTimer);
                this.singleTapTimer = null;
            }
            this.handleDoubleClick(e);
        } else {
            this.singleTapTimer = setTimeout(() => {
                this.handleSingleClick(e);
                this.singleTapTimer = null;
            }, this.tapDelay);
        }

        this.lastTapTime = now;
    }

    handleSingleClick(e) {
        const elementAtPoint = document.elementFromPoint(e.clientX, e.clientY);
        this.addLineHighlight(elementAtPoint || e.target);
    }

    handleDoubleClick(e) {
        e.preventDefault();
        window.getSelection().removeAllRanges();
        
        const range = this.selectWordAtPoint(e);
        if (range) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            setTimeout(() => {
                this.createHighlightFromSelection();
            }, 10);
        }
    }

    addLineHighlight(element) {
        let lineElement = this.findTextLine(element);
        if (!lineElement) return;
        
        if (this.currentLineHighlight) {
            this.currentLineHighlight.classList.remove('line-highlight');
        }
        
        if (this.currentLineHighlight === lineElement) {
            this.currentLineHighlight = null;
        } else {
            lineElement.classList.add('line-highlight');
            this.currentLineHighlight = lineElement;
        }
        
        this.bookReader.saveCurrentState();
    }

    findTextLine(element) {
        let current = element;
        let bestCandidate = null;
        
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.TEXT_NODE) {
                current = current.parentElement;
                continue;
            }
            
            if (current.matches && current.matches('span, a, em, strong, i, b, small, code, sup, sub')) {
                return current;
            }
            
            if (current.nodeType === Node.ELEMENT_NODE && 
                current.textContent.trim() && 
                current.offsetHeight > 0 && 
                current.offsetHeight < 150) {
                
                if (!bestCandidate || current.offsetHeight < bestCandidate.offsetHeight) {
                    bestCandidate = current;
                }
            }
            
            if (current.matches && current.matches('p, div, h1, h2, h3, h4, h5, h6, li, blockquote')) {
                if (current.offsetHeight < 100) {
                    return current;
                }
                break;
            }
            
            current = current.parentElement;
        }
        
        if (bestCandidate) {
            return bestCandidate;
        }
        
        current = element;
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.ELEMENT_NODE && current.textContent.trim()) {
                return current;
            }
            current = current.parentElement;
        }
        
        return element;
    }

    selectWordAtPoint(e) {
        const textNode = this.getTextNodeAtPoint(e.clientX, e.clientY);
        if (!textNode) return null;

        const text = textNode.textContent;
        const offset = this.getOffsetInTextNode(textNode, e.clientX, e.clientY);
        
        if (offset === -1) return null;

        const { start, end } = this.getWordBoundaries(text, offset);
        
        if (start < end) {
            const range = document.createRange();
            range.setStart(textNode, start);
            range.setEnd(textNode, end);
            return range;
        }
        
        return null;
    }

    getTextNodeAtPoint(x, y) {
        if (document.caretPositionFromPoint) {
            try {
                const position = document.caretPositionFromPoint(x, y);
                if (position && position.offsetNode && position.offsetNode.nodeType === Node.TEXT_NODE) {
                    return position.offsetNode;
                }
            } catch (e) {
                // Fallback to other methods
            }
        }
        
        if (document.caretRangeFromPoint) {
            try {
                const range = document.caretRangeFromPoint(x, y);
                if (range && range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) {
                    return range.startContainer;
                }
            } catch (e) {
                // Fallback to other methods
            }
        }
        
        const element = document.elementFromPoint(x, y);
        if (!element) return null;
        
        if (element.classList.contains('text-highlight')) {
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            const textNode = walker.nextNode();
            if (textNode) return textNode;
        }
        
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            {
                acceptNode: function(node) {
                    return node.textContent.trim().length > 0 ? 
                        NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                }
            },
            false
        );
        
        let bestTextNode = null;
        let bestDistance = Infinity;
        let textNode;
        
        while (textNode = walker.nextNode()) {
            const range = document.createRange();
            range.selectNodeContents(textNode);
            const rect = range.getBoundingClientRect();
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            
            if (distance < bestDistance) {
                bestDistance = distance;
                bestTextNode = textNode;
            }
        }
        
        return bestTextNode;
    }

    getOffsetInTextNode(textNode, x, y) {
        const text = textNode.textContent;
        if (!text) return 0;
        
        const range = document.createRange();
        let bestOffset = 0;
        let bestDistance = Infinity;
        
        for (let i = 0; i <= text.length; i++) {
            try {
                range.setStart(textNode, i);
                range.setEnd(textNode, Math.min(i + 1, text.length));
                
                const rect = range.getBoundingClientRect();
                if (!rect.width && !rect.height) continue;
                
                const charX = rect.left + rect.width / 2;
                const charY = rect.top + rect.height / 2;
                const distance = Math.sqrt(Math.pow(x - charX, 2) + Math.pow(y - charY, 2));
                
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestOffset = i;
                }
            } catch (e) {
                break;
            }
        }
        
        return Math.min(bestOffset, text.length);
    }

    getWordBoundaries(text, offset) {
        const wordRegex = /[\w''-]/;
        let start = offset;
        let end = offset;

        while (start > 0 && wordRegex.test(text[start - 1])) {
            start--;
        }

        while (end < text.length && wordRegex.test(text[end])) {
            end++;
        }

        if (start === end) {
            if (offset < text.length) {
                end = offset + 1;
            } else if (offset > 0) {
                start = offset - 1;
            }
        }

        if (end - start < 1 && start > 0) {
            start = Math.max(0, offset - 1);
            end = Math.min(text.length, offset + 1);
        }

        return { start, end };
    }

    createHighlightFromSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) return;

        const range = selection.getRangeAt(0);
        if (!this.isInBookContent(range.commonAncestorContainer)) return;

        const text = range.toString().trim();
        if (!text) return;

        // Find the section this highlight belongs to
        const section = this.findContainingSection(range.startContainer);
        if (!section || !section.id) {
            console.warn('Could not find section with ID for highlight');
            return;
        }

        const startChar = this.getCharPositionInSection(section, range.startContainer, range.startOffset);
        const endChar = this.getCharPositionInSection(section, range.endContainer, range.endOffset);
        
        if (startChar === -1 || endChar === -1) {
            console.warn('Could not calculate character positions');
            return;
        }

        const highlightId = this.generateHighlightId();
        const highlightData = {
            id: highlightId,
            pageNum: this.bookReader.currentPage,
            sectionId: section.id,
            startChar: startChar,
            endChar: endChar,
            color: 'yellow',
            comment: '',
            text: text
        };

        const span = document.createElement('span');
        span.className = `text-highlight highlight-${highlightData.color}`;
        span.dataset.highlightId = highlightData.id;

        try {
            range.surroundContents(span);
            this.addHighlight(highlightData);
            
            setTimeout(() => {
                this.selectHighlight(highlightData);
            }, 10);
            
        } catch (e) {
            console.warn('Could not create highlight:', e);
        }
        
        selection.removeAllRanges();
    }

    findContainingSection(node) {
        let current = node;
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.ELEMENT_NODE && current.id) {
                return current;
            }
            current = current.parentNode;
        }
        return null;
    }

    getCharPositionInSection(section, targetNode, targetOffset) {
        const walker = document.createTreeWalker(
            section,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let position = 0;
        let textNode;
        
        while (textNode = walker.nextNode()) {
            if (textNode === targetNode) {
                return position + targetOffset;
            }
            position += textNode.textContent.length;
        }
        
        return -1;
    }

    createRangeFromCharPositions(section, startChar, endChar) {
        const walker = document.createTreeWalker(
            section,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let currentPos = 0;
        let textNode;
        let startNode = null, startOffset = 0;
        let endNode = null, endOffset = 0;
        
        while (textNode = walker.nextNode()) {
            const nodeLength = textNode.textContent.length;
            
            if (!startNode && currentPos + nodeLength >= startChar) {
                startNode = textNode;
                startOffset = startChar - currentPos;
            }
            
            if (!endNode && currentPos + nodeLength >= endChar) {
                endNode = textNode;
                endOffset = endChar - currentPos;
                break;
            }
            
            currentPos += nodeLength;
        }
        
        if (!startNode || !endNode) return null;
        
        const range = document.createRange();
        range.setStart(startNode, startOffset);
        range.setEnd(endNode, endOffset);
        return range;
    }

    findHighlightById(highlightId) {
        for (const [pageNum, highlights] of this.highlights) {
            const highlight = highlights.find(h => h.id === highlightId);
            if (highlight) return highlight;
        }
        return null;
    }

    addHighlight(highlightData) {
        const pageNum = highlightData.pageNum;
        if (!this.highlights.has(pageNum)) {
            this.highlights.set(pageNum, []);
        }
        this.highlights.get(pageNum).push(highlightData);
        this.saveHighlights();
    }

    selectHighlight(highlightData) {
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
            el.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(handle => {
                handle.remove();
            });
        });

        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (element) {
            element.classList.add('selected');
            this.selectedHighlight = highlightData;
            this.addSmartResizeHandles(element);
            this.showPopup(highlightData);
        }
    }

    addSmartResizeHandles(element) {
        if (!this.selectedHighlight || element.dataset.highlightId !== this.selectedHighlight.id) {
            return;
        }
        
        document.querySelectorAll(`[data-highlight-id="${element.dataset.highlightId}"]`).forEach(el => {
            el.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(handle => {
                handle.remove();
            });
        });
        
        const allHighlightElements = Array.from(document.querySelectorAll(`[data-highlight-id="${element.dataset.highlightId}"]`));
        
        if (allHighlightElements.length === 0) return;
        
        const firstElement = allHighlightElements[0];
        const leftHandle = document.createElement('div');
        leftHandle.className = 'resize-handle-left';
        firstElement.appendChild(leftHandle);
        
        const lastElement = allHighlightElements[allHighlightElements.length - 1];
        const rightHandle = document.createElement('div');
        rightHandle.className = 'resize-handle-right';
        lastElement.appendChild(rightHandle);
    }

    showPopup(highlightData) {
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (!element) {
            console.warn('Could not find highlight element for popup');
            return;
        }

        const rect = element.getBoundingClientRect();
        const popup = this.popup;

        const commentDiv = document.getElementById('highlightComment');
        const textarea = commentDiv.querySelector('.comment-input');
        
        const commentText = highlightData.comment || '';
        textarea.value = commentText;
        this.autoResizeTextarea(textarea);
        
        document.querySelectorAll('[data-color]').forEach(pill => {
            const isSelected = pill.dataset.color === highlightData.color;
            if (isSelected) {
                pill.style.borderColor = '#3b82f6';
                pill.style.transform = 'scale(1.2)';
                pill.style.boxShadow = '0 4px 8px rgba(59, 130, 246, 0.3)';
            } else {
                pill.style.borderColor = 'transparent';
                pill.style.transform = 'scale(1)';
                pill.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            }
        });

        popup.style.display = 'block';
        
        requestAnimationFrame(() => {
            const popupRect = popup.getBoundingClientRect();
            
            let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
            left = Math.max(10, Math.min(left, window.innerWidth - popupRect.width - 10));
            
            let top = rect.top - popupRect.height - 15;
            if (top < 10) {
                top = rect.bottom + 15;
            }
            
            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
            popup.classList.add('show');
        });
    }

    hidePopup() {
        const popup = this.popup;
        popup.classList.remove('show');
        
        if (this.selectedHighlight) {
            const textarea = document.querySelector('.comment-input');
            if (textarea) {
                const newComment = textarea.value.trim();
                if (this.selectedHighlight.comment !== newComment) {
                    this.selectedHighlight.comment = newComment;
                    this.saveHighlights();
                }
            }
        }
        
        setTimeout(() => {
            popup.style.display = 'none';
        }, 200);
        
        this.selectedHighlight = null;
        this.isEditingComment = false;
        
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
        });
        
        document.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(handle => {
            handle.remove();
        });
        
        const commentDiv = document.getElementById('highlightComment');
        commentDiv.classList.remove('editing');
    }

    startEditing() {
        const commentDiv = document.getElementById('highlightComment');
        const textarea = commentDiv.querySelector('.comment-input');
        
        commentDiv.classList.add('editing');
        textarea.focus();
        
        this.autoResizeTextarea(textarea);
        
        let saveTimeout;
        const debouncedSave = () => {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                if (this.selectedHighlight) {
                    const newComment = textarea.value.trim();
                    if (this.selectedHighlight.comment !== newComment) {
                        this.selectedHighlight.comment = newComment;
                        this.saveHighlights();
                    }
                }
            }, 300);
        };
        
        textarea.removeEventListener('input', this.commentInputHandler);
        textarea.removeEventListener('blur', this.commentBlurHandler);
        
        this.commentInputHandler = () => {
            this.autoResizeTextarea(textarea);
            debouncedSave();
        };
        
        this.commentBlurHandler = () => {
            if (this.selectedHighlight) {
                const newComment = textarea.value.trim();
                if (this.selectedHighlight.comment !== newComment) {
                    this.selectedHighlight.comment = newComment;
                    this.saveHighlights();
                }
            }
        };
        
        textarea.addEventListener('input', this.commentInputHandler);
        textarea.addEventListener('blur', this.commentBlurHandler);
    }

    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        const newHeight = Math.max(20, textarea.scrollHeight);
        textarea.style.height = newHeight + 'px';
        textarea.rows = Math.max(1, Math.ceil(newHeight / 20));
    }

    changeHighlightColor(color) {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            element.classList.remove(`highlight-${this.selectedHighlight.color}`);
            element.classList.add(`highlight-${color}`);
            
            this.selectedHighlight.color = color;
            
            document.querySelectorAll('[data-color]').forEach(pill => {
                const isSelected = pill.dataset.color === color;
                if (isSelected) {
                    pill.style.borderColor = '#3b82f6';
                    pill.style.transform = 'scale(1.2)';
                    pill.style.boxShadow = '0 4px 8px rgba(59, 130, 246, 0.3)';
                } else {
                    pill.style.borderColor = 'transparent';
                    pill.style.transform = 'scale(1)';
                    pill.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                }
            });
            
            this.saveHighlights();
        }
    }

    deleteHighlight() {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            const parent = element.parentNode;
            const textNode = document.createTextNode(element.textContent);
            parent.replaceChild(textNode, element);
            parent.normalize();
        }

        const pageHighlights = this.highlights.get(this.selectedHighlight.pageNum);
        if (pageHighlights) {
            const index = pageHighlights.findIndex(h => h.id === this.selectedHighlight.id);
            if (index !== -1) {
                pageHighlights.splice(index, 1);
            }
        }

        this.saveHighlights();
        this.hidePopup();
    }

    restoreHighlights() {
        const pageHighlights = this.highlights.get(this.bookReader.currentPage);
        if (!pageHighlights || pageHighlights.length === 0) return;

        pageHighlights.forEach((highlightData) => {
            // Skip if highlight already exists
            if (document.querySelector(`[data-highlight-id="${highlightData.id}"]`)) {
                return;
            }

            try {
                const section = document.getElementById(highlightData.sectionId);
                if (!section) {
                    console.warn(`Section ${highlightData.sectionId} not found for highlight ${highlightData.id}`);
                    return;
                }

                const range = this.createRangeFromCharPositions(section, highlightData.startChar, highlightData.endChar);
                if (!range || range.collapsed) return;

                const span = document.createElement('span');
                span.className = `text-highlight highlight-${highlightData.color}`;
                span.dataset.highlightId = highlightData.id;
                
                try {
                    range.surroundContents(span);
                } catch (e) {
                    // Silently ignore surroundContents errors
                }
                
            } catch (e) {
                console.warn(`Failed to restore highlight ${highlightData.id}:`, e);
            }
        });

        this.addContentEventListeners();
    }

    isInBookContent(node) {
        const bookContent = document.getElementById('bookContent');
        while (node) {
            if (node === bookContent) return true;
            node = node.parentNode;
        }
        return false;
    }

    generateHighlightId() {
        return 'highlight_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    saveHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        
        try {
            const metadata = this.bookReader.getStoredMetadata();
            
            if (!metadata[bookName]) {
                metadata[bookName] = {};
            }
            
            if (!metadata[bookName].pages) {
                metadata[bookName].pages = {};
            }
            
            this.highlights.forEach((highlights, pageNum) => {
                if (highlights.length > 0) {
                    if (!metadata[bookName].pages[pageNum]) {
                        metadata[bookName].pages[pageNum] = {};
                    }
                    metadata[bookName].pages[pageNum].highlights = highlights;
                } else {
                    if (metadata[bookName].pages[pageNum]) {
                        delete metadata[bookName].pages[pageNum].highlights;
                        if (Object.keys(metadata[bookName].pages[pageNum]).length === 0) {
                            delete metadata[bookName].pages[pageNum];
                        }
                    }
                }
            });
            
            localStorage.setItem('bookMetadata', JSON.stringify(metadata));
            
        } catch (e) {
            console.warn('Failed to save highlights to bookMetadata:', e);
        }
    }

    loadHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        
        try {
            const metadata = this.bookReader.getStoredMetadata();
            const bookData = metadata[bookName];
            
            if (bookData && bookData.pages) {
                this.highlights.clear();
                
                Object.entries(bookData.pages).forEach(([pageNum, pageData]) => {
                    if (pageData.highlights && pageData.highlights.length > 0) {
                        this.highlights.set(parseInt(pageNum), pageData.highlights);
                    }
                });
                return;
            }
            
        } catch (e) {
            console.warn('Failed to load highlights:', e);
        }
    }
}

class BookReader {
    constructor() {
        this.currentFile = null;
        this.currentPage = 0;
        this.pages = [];
        this.tocItems = [];
        this.isTransitioning = false;
        this.setupEventListeners();
        this.setupIntersectionObserver();
        this.initializeTheme();
        this.highlightManager = new HighlightManager(this);
    }

    initializeTheme() {
        const storedTheme = localStorage.getItem('darkMode');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const isDark = storedTheme === 'true' || (!storedTheme && systemPrefersDark);
        
        if (isDark) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        
        const toggleButton = document.getElementById('darkModeToggle');
        toggleButton.addEventListener('click', () => {
            const newDarkMode = !document.documentElement.classList.contains('dark');
            document.documentElement.classList.toggle('dark', newDarkMode);
            localStorage.setItem('darkMode', newDarkMode.toString());
            
            // Update color pills when theme changes
            if (this.highlightManager) {
                this.highlightManager.updateColorPillColors();
            }
        });

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('darkMode')) {
                const newDarkMode = e.matches;
                document.documentElement.classList.toggle('dark', newDarkMode);
                
                // Update color pills when system theme changes
                if (this.highlightManager) {
                    this.highlightManager.updateColorPillColors();
                }
            }
        });
    }

    setupIntersectionObserver() {
        const contentWrapper = document.getElementById('contentWrapper');
        let isAtBottom = false;
        let isAtTop = true;

        const options = {
            root: null,
            rootMargin: '0px',
            threshold: 0
        };

        const topObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtTop = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        const bottomObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtBottom = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        topObserver.observe(document.getElementById('topSentinel'));
        bottomObserver.observe(document.getElementById('bottomSentinel'));

        let scrollSaveTimeout;
        contentWrapper.addEventListener('scroll', () => {
            const atBottom = contentWrapper.scrollHeight - contentWrapper.scrollTop <= contentWrapper.clientHeight + 1;
            if (atBottom !== isAtBottom) {
                isAtBottom = atBottom;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            }
            
            clearTimeout(scrollSaveTimeout);
            scrollSaveTimeout = setTimeout(() => {
                this.saveCurrentState();
            }, 300);
        });
    }

    updateControlsVisibility(isAtTop, isAtBottom) {
        const header = document.getElementById('header');
        const footer = document.getElementById('footer');
        
        if (!header || !footer) return;
        
        const updateClasses = (element, shouldBeVisible) => {
            if (shouldBeVisible) {
                element.classList.remove('controls-hidden');
                element.classList.add('controls-visible');
            } else {
                element.classList.remove('controls-visible');
                element.classList.add('controls-hidden');
            }
        };

        if (isAtTop) {
            updateClasses(header, true);
            updateClasses(footer, true);
        } else {
            updateClasses(header, false);
            updateClasses(footer, isAtBottom);
        }
    }

    setupEventListeners() {
        document.getElementById('prevButton').addEventListener('click', () => this.prevPage());
        document.getElementById('nextButton').addEventListener('click', () => this.nextPage());
        document.getElementById('tocSelect').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
        
        window.addEventListener('beforeunload', () => {
            this.saveCurrentState();
        });
        
        setInterval(() => {
            if (this.currentFile) {
                this.saveCurrentState();
            }
        }, 30000);
    }

    getStoredMetadata() {
        try {
            const stored = localStorage.getItem('bookMetadata');
            const metadata = stored ? JSON.parse(stored) : {};
            return metadata;
        } catch (e) {
            console.warn('⚠️ Could not load book metadata:', e);
            return {};
        }
    }

    saveCurrentState() {
        if (!this.currentFile?.name) return;
        
        const metadata = this.getStoredMetadata();
        const bookName = this.currentFile.name.replace(/\.html$/, '');
        
        const contentWrapper = document.getElementById('contentWrapper');
        const scrollTop = contentWrapper ? contentWrapper.scrollTop : 0;
        
        let lineMarkerPath = null;
        if (this.highlightManager.currentLineHighlight) {
            const section = this.highlightManager.findContainingSection(this.highlightManager.currentLineHighlight);
            if (section && section.id) {
                lineMarkerPath = {
                    sectionId: section.id
                };
            }
        }
        
        if (!metadata[bookName]) {
            metadata[bookName] = {};
        }
        
        metadata[bookName].lastPage = this.currentPage;
        metadata[bookName].scrollTop = scrollTop;
        metadata[bookName].lineMarkerPath = lineMarkerPath;
        
        try {
            localStorage.setItem('bookMetadata', JSON.stringify(metadata));
        } catch (e) {
            console.warn('⚠️ Could not save book metadata:', e);
        }
    }

    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const content = await file.text();
            this.currentFile = file;
            const bookName = file.name.replace(/\.html$/, '');
            
            document.getElementById('currentBookTitle').textContent = bookName;
            this.parseBook(content);
            
            if (this.pages.length === 0) {
                throw new Error('No readable content found in the book file');
            }
            
            const savedState = this.getStoredMetadata()[bookName] || {};
            this.currentPage = this.validatePageNumber(savedState.lastPage) ? savedState.lastPage : 0;
            
            this.highlightManager.loadHighlights();
            this.updateDisplay();
            
            await this.restoreBookState(savedState);
            
        } catch (error) {
            console.error('❌ Error loading book:', error);
            alert('Error reading file: ' + error.message);
        }

        event.target.value = '';
    }

    validatePageNumber(pageNum) {
        return pageNum !== undefined && 
               pageNum >= 0 && 
               pageNum < this.pages.length && 
               this.pages.length > 0;
    }

    async restoreBookState(savedState) {
        await this.waitForDOM(200);
        this.highlightManager.restoreHighlights();
        await this.waitForDOM(100);
        
        if (savedState.lineMarkerPath) {
            this.restoreLineMarker(savedState.lineMarkerPath);
        }
        
        await this.restoreScrollPosition(savedState.scrollTop);
    }

    waitForDOM(delay = 100) {
        return new Promise(resolve => {
            setTimeout(resolve, delay);
        });
    }

    restoreLineMarker(lineMarkerPath) {
        try {
            if (!lineMarkerPath || !lineMarkerPath.sectionId) return;
            
            const section = document.getElementById(lineMarkerPath.sectionId);
            if (section) {
                section.classList.add('line-highlight');
                this.highlightManager.currentLineHighlight = section;
            }
        } catch (e) {
            console.warn('⚠️ Error restoring line marker:', e);
        }
    }

    async restoreScrollPosition(scrollTop) {
        if (!scrollTop || scrollTop <= 0) return;
        
        const contentWrapper = document.getElementById('contentWrapper');
        if (!contentWrapper) return;
        
        for (let attempt = 0; attempt < 5; attempt++) {
            await new Promise(resolve => setTimeout(resolve, 50 * (attempt + 1)));
            contentWrapper.scrollTop = scrollTop;
            
            const actualScroll = contentWrapper.scrollTop;
            if (Math.abs(actualScroll - scrollTop) <= 10) {
                return;
            }
        }
    }

    parseBook(content) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        
        const chapters = doc.querySelectorAll('.chapter-loaded');
        this.pages = [];
        this.tocItems = [['Cover', 0]];

        if (chapters.length === 0) {
            const body = doc.body;
            if (body && body.textContent.trim()) {
                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-loaded';
                chapterDiv.innerHTML = this.cleanContent(body);
                this.pages.push(chapterDiv.outerHTML);
                this.tocItems.push(['Chapter 1', 0]);
            } else {
                console.warn('⚠️ No valid content found in HTML file');
                this.pages.push('<div class="chapter-loaded"><p>No content found in this book.</p></div>');
            }
        } else {
            chapters.forEach((chapter, index) => {
                const titleElem = chapter.querySelector('h1, h2, h3');
                if (titleElem) {
                    const title = titleElem.textContent.trim();
                    this.tocItems.push([title, this.pages.length]);
                } else {
                    this.tocItems.push([`Chapter ${index + 1}`, this.pages.length]);
                }

                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-loaded';
                chapterDiv.innerHTML = this.cleanContent(chapter);
                this.pages.push(chapterDiv.outerHTML);
            });
        }

        this.updateTOC();
    }

    cleanContent(element) {
        const clone = element.cloneNode(true);
        
        const cleanup = (node) => {
            if (node.nodeType === 1) {
                ['data-originalfontfamily', 'data-originalfontsize', 
                'data-originalcolor', 'data-originalbg', 'onload', 'onerror']
                    .forEach(attr => {
                        if (node.hasAttribute(attr)) {
                            node.removeAttribute(attr);
                        }
                    });

                if (node.hasAttribute('style')) {
                    const style = node.getAttribute('style');
                    const newStyle = style
                        .replace(/background-color:[^;]+;?/gi, '')
                        .replace(/color:[^;]+;?/gi, '')
                        .trim();
                    
                    if (newStyle) {
                        node.setAttribute('style', newStyle);
                    } else {
                        node.removeAttribute('style');
                    }
                }
                
                node.childNodes.forEach(cleanup);
            }
        };
        
        cleanup(clone);
        return clone.innerHTML;
    }

    updateTOC() {
        const tocSelect = document.getElementById('tocSelect');
        tocSelect.innerHTML = '<option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>';
        
        this.tocItems.forEach(([title, pageNum]) => {
            const option = document.createElement('option');
            option.value = pageNum;
            option.textContent = title;
            option.className = 'bg-white dark:bg-true-black';
            tocSelect.appendChild(option);
        });
    }

    scrollToTop() {
        const contentWrapper = document.getElementById('contentWrapper');
        
        const scrollMethods = [
            () => contentWrapper.scrollTo({
                top: 0,
                behavior: 'instant',
            }),
            () => contentWrapper.scrollTop = 0,
            () => contentWrapper.scrollTo(0, 0),
            () => contentWrapper.parentElement?.scrollTo(0, 0),
        ];

        scrollMethods.forEach(method => {
            try {
                method();
            } catch (e) {
                console.error('⚠️ Scroll method failed:', e);
            }
        });

        requestAnimationFrame(() => {
            if (contentWrapper.scrollTop !== 0) {
                contentWrapper.scrollTop = 0;
            }
        });
    }

    scrollToBottom() {
        const contentWrapper = document.getElementById('contentWrapper');
        contentWrapper.scrollTo({
            top: contentWrapper.scrollHeight,
            behavior: 'instant'
        });
    }

    prevPage() {
        if (this.currentPage > 0) {
            this.saveCurrentState();
            this.currentPage--;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToBottom();
            });
        }
    }

    nextPage() {
        if (this.currentPage < this.pages.length - 1 && !this.isTransitioning) {
            this.saveCurrentState();
            this.isTransitioning = true;
            this.currentPage++;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.isTransitioning = false;
            });
        }
    }

    goToPage(pageNum) {
        if (pageNum >= 0 && pageNum < this.pages.length) {
            this.saveCurrentState();
            this.currentPage = pageNum;
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToTop();
            });
        }
    }

    updateDisplay() {
        if (!this.pages.length) {
            document.getElementById('bookContent').innerHTML = 
                '<div class="chapter-loaded text-center text-gray-400 italic">No book selected</div>';
            return;
        }

        if (this.highlightManager.currentLineHighlight) {
            this.highlightManager.currentLineHighlight.classList.remove('line-highlight');
            this.highlightManager.currentLineHighlight = null;
        }

        this.highlightManager.hidePopup();

        const contentWrapper = document.getElementById('contentWrapper');
        const oldContent = document.getElementById('bookContent');
        
        oldContent.remove();
        void contentWrapper.offsetHeight;
        
        const newContent = document.createElement('div');
        newContent.id = 'bookContent';
        newContent.className = 'max-w-3xl mx-auto px-4';
        newContent.innerHTML = this.pages[this.currentPage];
        
        contentWrapper.insertBefore(newContent, contentWrapper.querySelector('#bottomSentinel'));
        void contentWrapper.offsetHeight;
        
        document.getElementById('pageIndicator').textContent = 
            `${this.currentPage + 1} / ${this.pages.length}`;
        
        document.getElementById('prevButton').disabled = (this.currentPage === 0);
        document.getElementById('nextButton').disabled = (this.currentPage === this.pages.length - 1);
        
        document.getElementById('tocSelect').value = this.currentPage;
        
        this.highlightManager.addContentEventListeners();

        setTimeout(() => {
            this.highlightManager.restoreHighlights();
        }, 100);
    }
}

window.addEventListener('DOMContentLoaded', () => {
    window.bookReader = new BookReader();
});
</script>
</body>
</html>
