<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Book Reader</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'true-black': '#000000'
                    }
                }
            }
        }
    </script>
    <style>
        #bookContent {
            position: relative; /* Ensure absolute positioning works correctly */
        }
        .controls-hidden { opacity: 0; pointer-events: none; }
        .controls-visible { opacity: 1; pointer-events: auto; }
        .nav-controls { transition: opacity 0.2s ease-in-out; }
        
        /* Theme aware content styles */
        .chapter-loaded {
            color: rgb(17, 24, 39) !important; /* text-gray-900 */
            background-color: white !important;
        }
        
        .dark .chapter-loaded {
            color: rgb(243, 244, 246) !important; /* text-gray-100 */
            background-color: black !important;
        }
        
        .chapter-loaded * {
            background-color: inherit !important;
            color: inherit !important;
        }

        /* Line highlighting for reading progress */
        .line-highlight {
            position: relative;
            background: linear-gradient(90deg, 
                rgba(59, 130, 246, 0.15) 0%, 
                rgba(59, 130, 246, 0.08) 100%) !important;
            border-left: 3px solid rgba(59, 130, 246, 0.6) !important;
            padding-left: 8px !important;
            margin-left: -11px !important;
            z-index: 5 !important;
        }

        .dark .line-highlight {
            background: linear-gradient(90deg, 
                rgba(147, 197, 253, 0.2) 0%, 
                rgba(147, 197, 253, 0.1) 100%) !important;
            border-left-color: rgba(147, 197, 253, 0.7) !important;
        }

        /* Enhanced drag handles - now with dynamic colors and single line height */
        .text-highlight.selected {
            position: relative;
            --handle-color: #3b82f6;
            --handle-color-dark: #1d4ed8;
            --handle-border: #ffffff;
        }

        .text-highlight.selected .resize-handle-left,
        .text-highlight.selected .resize-handle-right {
            position: absolute;
            width: 20px;
            height: 24px; /* Fixed single-line height */
            background: linear-gradient(135deg, var(--handle-color) 0%, var(--handle-color-dark) 100%);
            opacity: 1;
            cursor: ew-resize;
            z-index: 200;
            border-radius: 10px;
            border: 3px solid var(--handle-border);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Essential touch properties for iPad */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            
            /* Touch-friendly minimum size */
            min-width: 20px;
            min-height: 24px;
        }

        .text-highlight.selected .resize-handle-left {
            left: -10px;
            top: -2px; /* Position at start of first line */
        }

        .text-highlight.selected .resize-handle-right {
            right: -10px;
            bottom: -2px; /* Position at end of last line */
        }

        /* Enhanced hover and active states */
        .text-highlight.selected .resize-handle-left:hover,
        .text-highlight.selected .resize-handle-right:hover,
        .text-highlight.selected .resize-handle-left:active,
        .text-highlight.selected .resize-handle-right:active {
            transform: scale(1.15);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* Enhanced touch targets for mobile/tablet */
        @media (max-width: 1024px) {
            .text-highlight.selected .resize-handle-left,
            .text-highlight.selected .resize-handle-right {
                width: 24px;
                height: 28px;
                min-width: 24px;
                min-height: 28px;
                border-radius: 12px;
            }
            
            .text-highlight.selected .resize-handle-left {
                left: -12px;
                top: -4px;
            }
            
            .text-highlight.selected .resize-handle-right {
                right: -12px;
                bottom: -4px;
            }
        }

        /* Ghost handle that follows finger/mouse */
        .ghost-handle {
            position: fixed;
            width: 24px;
            height: 40px;
            background: linear-gradient(135deg, var(--handle-color) 0%, var(--handle-color-dark) 100%);
            border-radius: 12px;
            border: 3px solid var(--handle-border);
            box-shadow: 
                0 8px 20px rgba(0, 0, 0, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            pointer-events: none;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(1.2);
            transition: opacity 0.2s ease;
            
            /* Ensure it matches highlight colors */
            --handle-color: #3b82f6;
            --handle-color-dark: #1d4ed8;
            --handle-border: #ffffff;
        }

        .ghost-handle.visible {
            opacity: 0.9;
        }

        .ghost-handle.hidden {
            opacity: 0;
        }

        /* Selection preview overlay - now supports multiple rectangles for text flow */
        .selection-preview-segment {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.1s ease;
            transform: translateZ(0); /* Force GPU acceleration */
            
            /* Dynamic color support */
            --preview-bg: rgba(59, 130, 246, 0.15);
            --preview-border: rgba(59, 130, 246, 0.3);
            background: var(--preview-bg);
            border-color: var(--preview-border);
        }

        .selection-preview-segment.visible {
            opacity: 1;
        }

        /* Visual feedback during dragging */
        .text-highlight.selected.dragging {
            opacity: 0.7;
        }

        .text-highlight.selected.dragging .resize-handle-left,
        .text-highlight.selected.dragging .resize-handle-right {
            opacity: 0.3;
        }

        /* Light mode highlight colors - solid but subtle */
        .highlight-yellow { 
            background-color: #fef3c7 !important; 
            color: #92400e !important;
        }
        .highlight-green { 
            background-color: #d1fae5 !important; 
            color: #065f46 !important;
        }
        .highlight-blue { 
            background-color: #dbeafe !important; 
            color: #1e40af !important;
        }
        .highlight-pink { 
            background-color: #fce7f3 !important; 
            color: #be185d !important;
        }
        .highlight-purple { 
            background-color: #e9d5ff !important; 
            color: #7c2d12 !important;
        }
        .highlight-orange { 
            background-color: #fed7aa !important; 
            color: #c2410c !important;
        }

        /* Dark mode highlight colors - muted but visible */
        .dark .highlight-yellow { 
            background-color: #451a03 !important; 
            color: #fbbf24 !important;
        }
        .dark .highlight-green { 
            background-color: #064e3b !important; 
            color: #34d399 !important;
        }
        .dark .highlight-blue { 
            background-color: #1e3a8a !important; 
            color: #60a5fa !important;
        }
        .dark .highlight-pink { 
            background-color: #831843 !important; 
            color: #f472b6 !important;
        }
        .dark .highlight-purple { 
            background-color: #581c87 !important; 
            color: #c084fc !important;
        }
        .dark .highlight-orange { 
            background-color: #9a3412 !important; 
            color: #fb923c !important;
        }

        /* Enhanced selection styling that matches the highlight color */
        .text-highlight.selected {
            box-shadow: 
                0 0 0 2px currentColor,
                0 4px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.02);
            z-index: 10;
        }

        .dark .text-highlight.selected {
            box-shadow: 
                0 0 0 2px currentColor,
                0 4px 12px rgba(255, 255, 255, 0.1);
        }

        /* Popup menu */
        .highlight-popup {
            position: fixed;
            z-index: 1000;
            background: white;
            border: 1px solid rgb(229, 231, 235);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            min-width: 300px;
            max-width: 350px;
            user-select: none;
            -webkit-user-select: none;
            backdrop-filter: blur(8px);
            transform: translateY(-10px);
            opacity: 0;
            transition: all 0.2s ease;
            display: none;
        }

        .highlight-popup.show {
            transform: translateY(0);
            opacity: 1;
        }

        .dark .highlight-popup {
            background: rgba(17, 24, 39, 0.95);
            border-color: rgb(75, 85, 99);
        }

        .popup-header {
            position: relative;
            margin-bottom: 12px;
        }

        .popup-close {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgb(239, 68, 68);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .popup-close:hover {
            background: rgb(220, 38, 38);
            transform: scale(1.1);
        }

        .color-pills {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .color-pill {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .color-pill:hover {
            border-color: #3b82f6;
            transform: scale(1.15);
        }

        .color-pill.selected {
            border-color: #3b82f6;
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .color-pill.yellow { background-color: #fef3c7; }
        .color-pill.green { background-color: #d1fae5; }
        .color-pill.blue { background-color: #dbeafe; }
        .color-pill.pink { background-color: #fce7f3; }
        .color-pill.purple { background-color: #e9d5ff; }
        .color-pill.orange { background-color: #fed7aa; }

        .popup-comment {
            font-size: 14px;
            color: rgb(75, 85, 99);
            margin-top: 12px;
            padding: 8px 12px;
            background: transparent;
            border: 2px dashed rgba(156, 163, 175, 0.3);
            border-radius: 6px;
            min-height: 40px;
            cursor: text;
            transition: all 0.2s ease;
            line-height: 1.4;
        }

        .popup-comment:hover {
            border-color: rgba(59, 130, 246, 0.5);
        }

        .popup-comment.editing {
            border-style: solid;
            border-color: rgb(59, 130, 246);
            background: rgb(249, 250, 251);
        }

        .dark .popup-comment {
            color: rgb(156, 163, 175);
            border-color: rgba(156, 163, 175, 0.3);
        }

        .dark .popup-comment:hover {
            border-color: rgba(147, 197, 253, 0.5);
        }

        .dark .popup-comment.editing {
            border-color: rgb(147, 197, 253);
            background: rgb(31, 41, 55);
        }

        .comment-input {
            width: 100%;
            background: transparent;
            border: none;
            outline: none;
            font-size: 14px;
            color: inherit;
            font-family: inherit;
            line-height: inherit;
            resize: none;
            overflow: hidden;
        }

        .comment-input::placeholder {
            color: rgba(156, 163, 175, 0.6);
            font-style: italic;
        }

        .dark .comment-input::placeholder {
            color: rgba(156, 163, 175, 0.5);
        }

        .comment-input:focus {
            caret-color: rgb(59, 130, 246);
        }

        .dark .comment-input:focus {
            caret-color: rgb(147, 197, 253);
        }
    </style>
    <!-- Container for dynamically injected book styles -->
    <style id="bookStyles"></style>
</head>
<body class="bg-white dark:bg-true-black text-gray-900 dark:text-white min-h-screen transition-colors duration-200">
    <div class="min-h-screen flex flex-col">
        <div id="topSentinel" class="absolute top-0 h-1 w-full pointer-events-none"></div>
        
        <div id="header" class="fixed top-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-b border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="titleButton" onclick="document.getElementById('fileInput').click()" 
                        class="text-left hover:text-gray-600 dark:hover:text-gray-300 transition-colors cursor-pointer truncate flex-1">
                    <span id="currentBookTitle" class="text-lg font-medium">Select a Book...</span>
                </button>
                <input type="file" id="fileInput" accept=".html" class="hidden">

                <select id="tocSelect" class="ml-4 bg-transparent focus:outline-none hover:text-gray-600 dark:hover:text-gray-300 dark:text-white focus:text-gray-900 dark:focus:text-white cursor-pointer text-sm min-w-[200px]">
                    <option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>
                </select>

                <button id="darkModeToggle" class="ml-4 p-2 hover:text-gray-600 dark:hover:text-gray-300 transition-colors">
                    <i class="fas fa-moon text-blue-500 dark:hidden"></i>
                    <i class="fas fa-sun text-yellow-500 hidden dark:inline"></i>
                </button>
            </div>
        </div>

        <div id="contentWrapper" class="flex-1 overflow-y-auto bg-white dark:bg-true-black pt-12 pb-12">
            <div id="topSentinel" class="sticky top-0 h-1 w-full pointer-events-none"></div>
            
            <div id="bookContent" class="max-w-3xl mx-auto px-4">
                <div class="chapter-loaded">
                </div>
            </div>
            
            <div id="bottomSentinel" class="sticky bottom-0 h-1 w-full pointer-events-none"></div>
        </div>

        <div id="footer" class="fixed bottom-0 left-0 right-0 bg-white/95 dark:bg-true-black/95 border-t border-gray-200 dark:border-gray-700 z-10 nav-controls controls-visible backdrop-blur-sm">
            <div class="flex items-center justify-between px-4 h-12 max-w-3xl mx-auto">
                <button id="prevButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    ← Previous
                </button>
                <div id="pageIndicator" class="text-gray-500 dark:text-gray-400 text-sm">Page 0 of 0</div>
                <button id="nextButton" class="px-4 py-1 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    Next →
                </button>
            </div>
        </div>
    </div>

    <!-- Highlight popup menu -->
    <div id="highlightPopup" class="highlight-popup">
        <div class="relative mb-3">
            <button class="absolute -top-2 -right-2 w-6 h-6 rounded-full bg-red-500 text-white border-0 cursor-pointer flex items-center justify-center text-xs transition-all duration-200 shadow-sm hover:bg-red-600 hover:scale-110" id="deleteHighlightBtn">
                <i class="fas fa-times"></i>
            </button>
            <div class="flex gap-2.5 justify-center">
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="yellow" id="pill-yellow"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="green" id="pill-green"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="blue" id="pill-blue"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="pink" id="pill-pink"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="purple" id="pill-purple"></div>
                <div class="w-7 h-7 rounded-full border-3 border-transparent cursor-pointer transition-all duration-200 shadow-sm hover:border-blue-500 hover:scale-110" 
                     data-color="orange" id="pill-orange"></div>
            </div>
        </div>
        <div class="popup-comment" id="highlightComment">
            <textarea class="comment-input" placeholder="Tap to add a comment..." rows="1"></textarea>
        </div>
    </div>

<script>
class StyleProcessor {
    constructor() {
        this.styleElement = document.getElementById('bookStyles');
        // Properties that affect coloring and should be removed
        this.colorProperties = [
            'color',
            'background-color',
            'background',
            'border-color',
            'outline-color',
            'text-decoration-color',
            'text-emphasis-color',
            'column-rule-color',
            'caret-color',
            'fill',
            'stroke',
            'stop-color',
            'flood-color',
            'lighting-color'
        ];
    }

    extractAndProcessStyles(doc) {
        const styles = doc.querySelectorAll('style');
        let processedCSS = '';

        styles.forEach(styleTag => {
            const cssText = styleTag.textContent;
            const cleanedCSS = this.processCSS(cssText);
            if (cleanedCSS) {
                processedCSS += cleanedCSS + '\n';
            }
        });

        // Also extract styles from link tags if they reference internal styles
        const inlineStyles = doc.querySelectorAll('style[type="text/css"]');
        inlineStyles.forEach(styleTag => {
            const cssText = styleTag.textContent;
            const cleanedCSS = this.processCSS(cssText);
            if (cleanedCSS && !processedCSS.includes(cleanedCSS)) {
                processedCSS += cleanedCSS + '\n';
            }
        });

        return processedCSS;
    }

    processCSS(cssText) {
        if (!cssText || !cssText.trim()) return '';

        try {
            // Split CSS into rules while preserving media queries and keyframes
            const rules = this.parseCSS(cssText);
            const processedRules = [];

            rules.forEach(rule => {
                if (rule.type === 'media') {
                    // Process media query
                    const processedMedia = this.processMediaQuery(rule);
                    if (processedMedia) {
                        processedRules.push(processedMedia);
                    }
                } else if (rule.type === 'keyframes') {
                    // Keep keyframes as-is but remove color properties
                    const processedKeyframes = this.processKeyframes(rule);
                    if (processedKeyframes) {
                        processedRules.push(processedKeyframes);
                    }
                } else if (rule.type === 'rule') {
                    // Process regular CSS rule
                    const processedRule = this.processRule(rule);
                    if (processedRule) {
                        processedRules.push(processedRule);
                    }
                }
            });

            return processedRules.join('\n');
        } catch (e) {
            console.warn('Failed to process CSS:', e);
            return '';
        }
    }

    parseCSS(cssText) {
        const rules = [];
        let currentPos = 0;

        // Simple CSS parser that handles media queries, keyframes, and regular rules
        const cssString = cssText.trim();
        
        // Regular expression patterns
        const mediaQueryRegex = /@media[^{]+{/g;
        const keyframesRegex = /@(?:keyframes|webkit-keyframes|moz-keyframes)[^{]+{/g;
        const ruleRegex = /([^{}]+){([^}]*)}/g;

        // First, handle special at-rules (media queries and keyframes)
        let processedCSS = cssString;
        
        // Extract media queries
        const mediaMatches = [...cssString.matchAll(/@media[^{]+{[^{}]*(?:{[^}]*}[^{}]*)*}/g)];
        mediaMatches.forEach(match => {
            const mediaContent = match[0];
            const mediaCondition = mediaContent.match(/@media([^{]+){/)[1];
            const innerContent = mediaContent.substring(mediaContent.indexOf('{') + 1, mediaContent.lastIndexOf('}'));
            
            rules.push({
                type: 'media',
                condition: mediaCondition.trim(),
                content: innerContent
            });
            
            processedCSS = processedCSS.replace(mediaContent, '');
        });

        // Extract keyframes
        const keyframesMatches = [...cssString.matchAll(/@(?:keyframes|webkit-keyframes|moz-keyframes)([^{]+){[^{}]*(?:{[^}]*}[^{}]*)*}/g)];
        keyframesMatches.forEach(match => {
            const keyframesContent = match[0];
            const keyframesName = keyframesContent.match(/@(?:keyframes|webkit-keyframes|moz-keyframes)([^{]+){/)[1];
            const innerContent = keyframesContent.substring(keyframesContent.indexOf('{') + 1, keyframesContent.lastIndexOf('}'));
            
            rules.push({
                type: 'keyframes',
                name: keyframesName.trim(),
                content: innerContent
            });
            
            processedCSS = processedCSS.replace(keyframesContent, '');
        });

        // Now process regular rules from the remaining CSS
        let ruleMatch;
        ruleRegex.lastIndex = 0;
        while ((ruleMatch = ruleRegex.exec(processedCSS)) !== null) {
            const selector = ruleMatch[1].trim();
            const declarations = ruleMatch[2].trim();
            
            if (selector && declarations) {
                rules.push({
                    type: 'rule',
                    selector: selector,
                    declarations: declarations
                });
            }
        }

        return rules;
    }

    processRule(rule) {
        const declarations = this.parseDeclarations(rule.declarations);
        const cleanedDeclarations = declarations.filter(decl => {
            const property = decl.property.toLowerCase();
            return !this.colorProperties.some(colorProp => property.includes(colorProp));
        });

        if (cleanedDeclarations.length === 0) {
            return null;
        }

        const declarationsString = cleanedDeclarations
            .map(decl => `${decl.property}: ${decl.value};`)
            .join(' ');

        return `${rule.selector} { ${declarationsString} }`;
    }

    processMediaQuery(rule) {
        const innerRules = this.parseCSS(rule.content);
        const processedInnerRules = [];

        innerRules.forEach(innerRule => {
            if (innerRule.type === 'rule') {
                const processed = this.processRule(innerRule);
                if (processed) {
                    processedInnerRules.push(processed);
                }
            }
        });

        if (processedInnerRules.length === 0) {
            return null;
        }

        return `@media ${rule.condition} {\n${processedInnerRules.join('\n')}\n}`;
    }

    processKeyframes(rule) {
        // Process keyframe content to remove color properties
        const keyframeRules = rule.content.match(/[^{}]+{[^}]*}/g) || [];
        const processedKeyframeRules = [];

        keyframeRules.forEach(keyframeRule => {
            const match = keyframeRule.match(/([^{]+){([^}]*)}/);
            if (match) {
                const selector = match[1].trim();
                const declarations = this.parseDeclarations(match[2]);
                const cleanedDeclarations = declarations.filter(decl => {
                    const property = decl.property.toLowerCase();
                    return !this.colorProperties.some(colorProp => property.includes(colorProp));
                });

                if (cleanedDeclarations.length > 0) {
                    const declarationsString = cleanedDeclarations
                        .map(decl => `${decl.property}: ${decl.value};`)
                        .join(' ');
                    processedKeyframeRules.push(`${selector} { ${declarationsString} }`);
                }
            }
        });

        if (processedKeyframeRules.length === 0) {
            return null;
        }

        return `@keyframes ${rule.name} {\n${processedKeyframeRules.join('\n')}\n}`;
    }

    parseDeclarations(declarationsString) {
        const declarations = [];
        const declArray = declarationsString.split(';');

        declArray.forEach(decl => {
            const colonIndex = decl.indexOf(':');
            if (colonIndex > 0) {
                const property = decl.substring(0, colonIndex).trim();
                const value = decl.substring(colonIndex + 1).trim();
                if (property && value) {
                    declarations.push({ property, value });
                }
            }
        });

        return declarations;
    }

    injectStyles(cssText) {
        if (this.styleElement && cssText) {
            this.styleElement.textContent = cssText;
        }
    }

    clearStyles() {
        if (this.styleElement) {
            this.styleElement.textContent = '';
        }
    }
}

class HighlightManager {
    constructor(bookReader) {
        this.bookReader = bookReader;
        this.highlights = new Map();
        this.selectedHighlight = null;
        this.popup = document.getElementById('highlightPopup');
        this.isEditingComment = false;
        this.currentLineHighlight = null;
        
        // Enhanced drag state management
        this.isResizing = false;
        this.resizeHandle = null;
        this.resizingHighlight = null;
        this.isDragPreview = false;
        this.ghostHandle = null;
        this.selectionPreviewSegments = []; // Changed to array for multiple segments
        
        // Unified gesture recognition for both mouse and touch
        this.startX = 0;
        this.startY = 0;
        this.hasMoved = false;
        this.dragThreshold = 10; // pixels before starting drag (lower for mouse)
        this.dragStarted = false;
        
        // Performance optimization
        this.rafId = null;
        this.pendingUpdate = false;
        
        // Tap handling
        this.lastTapTime = 0;
        this.tapDelay = 300;
        this.singleTapTimer = null;
        
        // Resize capture data
        this.capturedSectionId = null;
        this.capturedStartChar = null;
        this.capturedEndChar = null;
        this.originalHighlightRect = null;
        
        // Preview boundaries
        this.previewStartChar = null;
        this.previewEndChar = null;
        
        this.handleClick = this.handleClick.bind(this);
        this.handleMouseDown = this.handleMouseDown.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        
        this.setupEventListeners();
        this.loadHighlights();
        this.updateColorPillColors();
    }

    setupEventListeners() {
        document.getElementById('deleteHighlightBtn').addEventListener('click', () => this.deleteHighlight());
        document.getElementById('highlightComment').addEventListener('click', () => this.startEditing());
        
        document.querySelectorAll('[data-color]').forEach(pill => {
            pill.addEventListener('click', (e) => this.changeHighlightColor(e.target.dataset.color));
        });
        
        document.addEventListener('click', (e) => {
            if (!this.popup.contains(e.target) && !e.target.closest('.text-highlight')) {
                this.hidePopup();
            }
        });

        // Mouse events
        document.addEventListener('mousedown', this.handleMouseDown);
        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
        
        // Touch events with explicit passive: false for proper drag handling
        document.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
        document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
        document.addEventListener('touchcancel', this.handleTouchEnd.bind(this), { passive: false });

        this.addContentEventListeners();
    }

    // RAF throttling utility
    throttleWithRAF(callback) {
        if (this.pendingUpdate) return;
        
        this.pendingUpdate = true;
        this.rafId = requestAnimationFrame(() => {
            callback();
            this.pendingUpdate = false;
        });
    }

    // Get color values for dynamic handle styling
    getHighlightColor(element) {
        const computedStyle = window.getComputedStyle(element);
        const bgColor = computedStyle.backgroundColor;
        
        // Parse RGB values
        const rgb = bgColor.match(/\d+/g);
        if (!rgb || rgb.length < 3) {
            return { r: 59, g: 130, b: 246 }; // fallback blue
        }
        
        return {
            r: parseInt(rgb[0]),
            g: parseInt(rgb[1]),
            b: parseInt(rgb[2])
        };
    }

    // Apply dynamic colors to handles and ghost
    updateHandleColors(element, colorName) {
        const colorMap = {
            yellow: { r: 217, g: 166, b: 7 },
            green: { r: 22, g: 101, b: 52 },
            blue: { r: 59, g: 130, b: 246 },
            pink: { r: 190, g: 24, b: 93 },
            purple: { r: 107, g: 33, b: 168 },
            orange: { r: 194, g: 65, b: 12 }
        };

        const isDark = document.documentElement.classList.contains('dark');
        let color = colorMap[colorName] || colorMap.blue;
        
        // Adjust for dark mode
        if (isDark) {
            color = {
                r: Math.min(255, color.r + 50),
                g: Math.min(255, color.g + 50),
                b: Math.min(255, color.b + 50)
            };
        }

        const handleColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
        const handleColorDark = `rgb(${Math.max(0, color.r - 30)}, ${Math.max(0, color.g - 30)}, ${Math.max(0, color.b - 30)})`;
        const borderColor = isDark ? '#1f2937' : '#ffffff';
        
        // Preview colors (more transparent)
        const previewBg = `rgba(${color.r}, ${color.g}, ${color.b}, 0.15)`;
        const previewBorder = `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`;

        element.style.setProperty('--handle-color', handleColor);
        element.style.setProperty('--handle-color-dark', handleColorDark);
        element.style.setProperty('--handle-border', borderColor);
        
        // Update ghost handle colors if it exists
        if (this.ghostHandle) {
            this.ghostHandle.style.setProperty('--handle-color', handleColor);
            this.ghostHandle.style.setProperty('--handle-color-dark', handleColorDark);
            this.ghostHandle.style.setProperty('--handle-border', borderColor);
        }
        
        // Update selection preview colors for all segments
        this.selectionPreviewSegments.forEach(segment => {
            segment.style.setProperty('--preview-bg', previewBg);
            segment.style.setProperty('--preview-border', previewBorder);
        });
    }

    updateColorPillColors() {
        const isDark = document.documentElement.classList.contains('dark');
        
        const colors = {
            yellow: isDark ? '#a16207' : '#fef08a',
            green: isDark ? '#166534' : '#86efac', 
            blue: isDark ? '#0c4a6e' : '#7dd3fc',
            pink: isDark ? '#be185d' : '#f9a8d4',
            purple: isDark ? '#6b21a8' : '#c4b5fd',
            orange: isDark ? '#c2410c' : '#fdba74'
        };
        
        Object.entries(colors).forEach(([color, bgColor]) => {
            const pill = document.getElementById(`pill-${color}`);
            if (pill) {
                pill.style.backgroundColor = bgColor;
            }
        });
    }

    addContentEventListeners() {
        const bookContent = document.getElementById('bookContent');
        bookContent.removeEventListener('click', this.handleClick);
        bookContent.addEventListener('click', this.handleClick);
    }

    getEventCoordinates(e) {
        // Handle touch events more robustly
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        // Handle touchend events that might not have touches
        if (e.changedTouches && e.changedTouches.length > 0) {
            return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        }
        // Mouse events
        return { x: e.clientX, y: e.clientY };
    }

    // Create ghost handle that follows finger/mouse
    createGhostHandle() {
        if (this.ghostHandle) {
            this.ghostHandle.remove();
        }
        
        const ghost = document.createElement('div');
        ghost.className = 'ghost-handle hidden';
        
        // Match colors from the current highlight
        if (this.selectedHighlight) {
            this.updateGhostColors(ghost, this.selectedHighlight.color);
        }
        
        document.body.appendChild(ghost);
        this.ghostHandle = ghost;
        
        return ghost;
    }

    // Create multiple selection preview segments that follow text flow
    createSelectionPreviewSegments(range) {
        // Clean up existing segments
        this.cleanupSelectionPreview();
        
        if (!range) return;
        
        try {
            // Get all rectangles that the range spans
            const rects = range.getClientRects();
            const bookContent = document.getElementById('bookContent');
            
            if (!bookContent) return;
            
            // Get bookContent's position in viewport coordinates
            const bookRect = bookContent.getBoundingClientRect();
            
            // Create a preview segment for each rectangle
            for (let i = 0; i < rects.length; i++) {
                const rect = rects[i];
                
                // Skip empty rectangles
                if (rect.width === 0 || rect.height === 0) continue;
                
                const segment = document.createElement('div');
                segment.className = 'selection-preview-segment';
                
                // Convert viewport coordinates to bookContent-relative coordinates
                // rect coordinates are relative to viewport
                // bookRect coordinates are also relative to viewport
                // Subtract to get position relative to bookContent
                const left = rect.left - bookRect.left;
                const top = rect.top - bookRect.top;
                
                segment.style.left = left + 'px';
                segment.style.top = top + 'px';
                segment.style.width = rect.width + 'px';
                segment.style.height = rect.height + 'px';
                
                // Match colors from the current highlight
                if (this.selectedHighlight) {
                    this.updatePreviewSegmentColors(segment, this.selectedHighlight.color);
                }
                
                bookContent.appendChild(segment);
                this.selectionPreviewSegments.push(segment);
            }
            
        } catch (e) {
            console.warn('Failed to create preview segments:', e);
        }
    }

    // Clean up selection preview segments
    cleanupSelectionPreview() {
        this.selectionPreviewSegments.forEach(segment => {
            try {
                if (segment.parentNode) {
                    segment.parentNode.removeChild(segment);
                }
            } catch (e) {
                // Ignore cleanup errors
            }
        });
        this.selectionPreviewSegments = [];
    }

    // Update ghost handle colors
    updateGhostColors(ghost, colorName) {
        const colorMap = {
            yellow: { r: 217, g: 166, b: 7 },
            green: { r: 22, g: 101, b: 52 },
            blue: { r: 59, g: 130, b: 246 },
            pink: { r: 190, g: 24, b: 93 },
            purple: { r: 107, g: 33, b: 168 },
            orange: { r: 194, g: 65, b: 12 }
        };

        const isDark = document.documentElement.classList.contains('dark');
        let color = colorMap[colorName] || colorMap.blue;
        
        if (isDark) {
            color = {
                r: Math.min(255, color.r + 50),
                g: Math.min(255, color.g + 50),
                b: Math.min(255, color.b + 50)
            };
        }

        const handleColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
        const handleColorDark = `rgb(${Math.max(0, color.r - 30)}, ${Math.max(0, color.g - 30)}, ${Math.max(0, color.b - 30)})`;
        const borderColor = isDark ? '#1f2937' : '#ffffff';

        ghost.style.setProperty('--handle-color', handleColor);
        ghost.style.setProperty('--handle-color-dark', handleColorDark);
        ghost.style.setProperty('--handle-border', borderColor);
    }

    // Update preview segment colors
    updatePreviewSegmentColors(segment, colorName) {
        const colorMap = {
            yellow: { r: 217, g: 166, b: 7 },
            green: { r: 22, g: 101, b: 52 },
            blue: { r: 59, g: 130, b: 246 },
            pink: { r: 190, g: 24, b: 93 },
            purple: { r: 107, g: 33, b: 168 },
            orange: { r: 194, g: 65, b: 12 }
        };

        let color = colorMap[colorName] || colorMap.blue;
        
        const previewBg = `rgba(${color.r}, ${color.g}, ${color.b}, 0.15)`;
        const previewBorder = `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`;

        segment.style.setProperty('--preview-bg', previewBg);
        segment.style.setProperty('--preview-border', previewBorder);
    }

    // Start visual drag preview with ghost handle
    startDragPreview() {
        if (this.isDragPreview || !this.resizingHighlight) return;
        
        this.isDragPreview = true;
        this.dragStarted = true;
        
        // Add visual feedback to the highlight
        this.resizingHighlight.classList.add('dragging');
        
        // Store original highlight bounds
        this.originalHighlightRect = this.resizingHighlight.getBoundingClientRect();
        
        // Create ghost handle
        this.createGhostHandle();
        
        // Initialize preview bounds
        this.previewStartChar = this.capturedStartChar;
        this.previewEndChar = this.capturedEndChar;
        
        // Prevent document interaction
        document.body.style.userSelect = 'none';
        document.body.style.webkitUserSelect = 'none';
        document.body.style.touchAction = 'none';
        document.body.style.cursor = 'ew-resize';
    }

    // Update ghost handle position and selection preview
    updateDragPreview(coords) {
        if (!this.isDragPreview) return;
        
        this.throttleWithRAF(() => {
            // Update ghost handle position
            if (this.ghostHandle) {
                this.ghostHandle.style.left = coords.x + 'px';
                this.ghostHandle.style.top = coords.y + 'px';
                this.ghostHandle.classList.remove('hidden');
                this.ghostHandle.classList.add('visible');
            }
            
            // Update selection preview bounds
            this.updateSelectionPreview(coords);
        });
    }

    // Update selection preview based on ghost position
    updateSelectionPreview(coords) {
        if (!this.selectedHighlight) return;
        
        try {
            // Get text node at ghost position
            const textNode = this.getTextNodeAtPoint(coords.x, coords.y);
            if (!textNode) return;

            const offset = this.getOffsetInTextNode(textNode, coords.x, coords.y);
            const section = document.getElementById(this.capturedSectionId);
            if (!section) return;
            
            const clickPosition = this.getCharPositionInSection(section, textNode, offset);
            if (clickPosition === -1) return;
            
            // Calculate new preview bounds
            let newStart, newEnd;
            if (this.resizeHandle === 'left') {
                newStart = clickPosition;
                newEnd = this.capturedEndChar;
            } else {
                newStart = this.capturedStartChar;
                newEnd = clickPosition;
            }
            
            if (newStart >= newEnd) {
                // Invalid range - hide all segments
                this.selectionPreviewSegments.forEach(segment => {
                    segment.classList.remove('visible');
                });
                return;
            }
            
            // Update preview character bounds
            this.previewStartChar = newStart;
            this.previewEndChar = newEnd;
            
            // Create range for preview positioning
            const previewRange = this.createRangeFromCharPositions(section, newStart, newEnd);
            if (!previewRange) {
                // Invalid range - hide all segments
                this.selectionPreviewSegments.forEach(segment => {
                    segment.classList.remove('visible');
                });
                return;
            }
            
            // Create multiple preview segments that follow text flow with corrected positioning
            this.createSelectionPreviewSegments(previewRange);
            
            // Show all segments
            this.selectionPreviewSegments.forEach(segment => {
                segment.classList.add('visible');
            });
            
        } catch (e) {
            // Silently handle errors during preview
            console.warn('Preview update failed:', e);
        }
    }

    // Commit drag changes (only on mouse up / touch end)
    commitDragChanges() {
        if (!this.selectedHighlight || !this.resizingHighlight || !this.isDragPreview) return;
        
        // Use the preview bounds for final commit
        if (this.previewStartChar === null || this.previewEndChar === null) return;
        
        try {
            const section = document.getElementById(this.capturedSectionId);
            if (!section) return;
            
            const newStart = this.previewStartChar;
            const newEnd = this.previewEndChar;
            
            if (newStart >= newEnd) return; // Invalid range
            
            const sectionText = section.textContent;
            const newText = sectionText.substring(newStart, newEnd);
            if (!newText.trim()) return;
            
            // Remove old highlight
            const parent = this.resizingHighlight.parentNode;
            if (parent) {
                parent.replaceChild(document.createTextNode(this.resizingHighlight.textContent), this.resizingHighlight);
                parent.normalize();
            }
            
            // Create new highlight
            const newRange = this.createRangeFromCharPositions(section, newStart, newEnd);
            if (!newRange) return;
            
            const span = document.createElement('span');
            span.className = `text-highlight highlight-${this.selectedHighlight.color} selected`;
            span.dataset.highlightId = this.selectedHighlight.id;
            
            try {
                newRange.surroundContents(span);
            } catch (e) {
                // Silently ignore surroundContents errors
            }
            
            // Update stored data
            this.selectedHighlight.startChar = newStart;
            this.selectedHighlight.endChar = newEnd;
            this.selectedHighlight.text = newText;
            
            this.resizingHighlight = span;
            setTimeout(() => {
                this.addSmartResizeHandles(span);
                this.updateHandleColors(span, this.selectedHighlight.color);
            }, 10);
            
        } catch (err) {
            console.warn('Resize failed:', err);
        }
    }

    // Clean up drag elements
    cleanupDragElements() {
        // Remove ghost handle
        if (this.ghostHandle) {
            this.ghostHandle.remove();
            this.ghostHandle = null;
        }
        
        // Remove selection preview segments
        this.cleanupSelectionPreview();
        
        // Remove dragging visual feedback
        if (this.resizingHighlight) {
            this.resizingHighlight.classList.remove('dragging');
        }
    }

    // Unified drag start handler for both mouse and touch
    startDragHandler(e) {
        // Check if this is a resize handle
        if (e.target.classList.contains('resize-handle-left') || e.target.classList.contains('resize-handle-right')) {
            e.preventDefault();
            e.stopPropagation();
            
            const coords = this.getEventCoordinates(e);
            this.startX = coords.x;
            this.startY = coords.y;
            this.hasMoved = false;
            this.dragStarted = false;
            
            this.isResizing = true;
            this.resizeHandle = e.target.classList.contains('resize-handle-left') ? 'left' : 'right';
            this.resizingHighlight = e.target.closest('.text-highlight.selected');
            
            if (!this.resizingHighlight) {
                this.isResizing = false;
                return;
            }
            
            // Capture current highlight position data
            const highlightData = this.selectedHighlight;
            this.capturedSectionId = highlightData.sectionId;
            this.capturedStartChar = highlightData.startChar;
            this.capturedEndChar = highlightData.endChar;
            
            return;
        }
    }

    // Unified drag move handler for both mouse and touch
    dragMoveHandler(e) {
        if (this.isResizing && this.resizingHighlight) {
            e.preventDefault();
            e.stopPropagation();
            
            const coords = this.getEventCoordinates(e);
            
            // Check if we've moved beyond threshold
            const deltaX = Math.abs(coords.x - this.startX);
            const deltaY = Math.abs(coords.y - this.startY);
            const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (totalMovement > this.dragThreshold && !this.dragStarted) {
                this.startDragPreview();
            }
            
            if (this.isDragPreview) {
                this.updateDragPreview(coords);
            }
            
            this.hasMoved = totalMovement > 5;
        }
    }

    // Unified drag end handler for both mouse and touch
    dragEndHandler(e) {
        if (this.isResizing) {
            e.preventDefault();
            e.stopPropagation();
            
            // Commit changes if we actually dragged
            if (this.dragStarted && this.hasMoved) {
                this.commitDragChanges();
            }
            
            // Clean up drag elements
            this.cleanupDragElements();
            
            this.isResizing = false;
            this.resizeHandle = null;
            this.resizingHighlight = null;
            this.dragStarted = false;
            this.isDragPreview = false;
            
            // Clean up captured data
            this.capturedSectionId = null;
            this.capturedStartChar = null;
            this.capturedEndChar = null;
            this.previewStartChar = null;
            this.previewEndChar = null;
            
            // Restore document interaction
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
            document.body.style.touchAction = '';
            document.body.style.cursor = '';
            
            this.saveHighlights();
        }
    }

    // Touch event handlers
    handleTouchStart(e) {
        this.startDragHandler(e);
    }

    handleTouchMove(e) {
        this.dragMoveHandler(e);
    }

    handleTouchEnd(e) {
        this.dragEndHandler(e);
    }

    // Mouse event handlers - now unified with touch
    handleMouseDown(e) {
        this.startDragHandler(e);
    }

    handleMouseMove(e) {
        if (!this.isResizing) {
            // Handle cursor changes for hover
            if (e.target.classList.contains('resize-handle-left') || e.target.classList.contains('resize-handle-right')) {
                document.body.style.cursor = 'ew-resize';
            } else {
                document.body.style.cursor = '';
            }
            return;
        }
        
        this.dragMoveHandler(e);
    }

    handleMouseUp(e) {
        this.dragEndHandler(e);
    }

    handleClick(e) {
        if (e.target.closest('.text-highlight')) {
            const highlightElement = e.target.closest('.text-highlight');
            const highlightId = highlightElement.dataset.highlightId;
            const highlightData = this.findHighlightById(highlightId);
            if (highlightData) {
                this.selectHighlight(highlightData);
            }
            return;
        }

        if (!this.isInBookContent(e.target)) return;

        const now = Date.now();
        const timeSinceLastTap = now - this.lastTapTime;

        if (timeSinceLastTap < this.tapDelay) {
            if (this.singleTapTimer) {
                clearTimeout(this.singleTapTimer);
                this.singleTapTimer = null;
            }
            this.handleDoubleClick(e);
        } else {
            this.singleTapTimer = setTimeout(() => {
                this.handleSingleClick(e);
                this.singleTapTimer = null;
            }, this.tapDelay);
        }

        this.lastTapTime = now;
    }

    handleSingleClick(e) {
        const elementAtPoint = document.elementFromPoint(e.clientX, e.clientY);
        this.addLineHighlight(elementAtPoint || e.target);
    }

    handleDoubleClick(e) {
        e.preventDefault();
        window.getSelection().removeAllRanges();
        
        const range = this.selectWordAtPoint(e);
        if (range) {
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            setTimeout(() => {
                this.createHighlightFromSelection();
            }, 10);
        }
    }

    addLineHighlight(element) {
        let lineElement = this.findTextLine(element);
        if (!lineElement) return;
        
        if (this.currentLineHighlight) {
            this.currentLineHighlight.classList.remove('line-highlight');
        }
        
        if (this.currentLineHighlight === lineElement) {
            this.currentLineHighlight = null;
        } else {
            lineElement.classList.add('line-highlight');
            this.currentLineHighlight = lineElement;
        }
        
        this.bookReader.saveCurrentState();
    }

    findTextLine(element) {
        let current = element;
        let bestCandidate = null;
        
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.TEXT_NODE) {
                current = current.parentElement;
                continue;
            }
            
            if (current.matches && current.matches('span, a, em, strong, i, b, small, code, sup, sub')) {
                return current;
            }
            
            if (current.nodeType === Node.ELEMENT_NODE && 
                current.textContent.trim() && 
                current.offsetHeight > 0 && 
                current.offsetHeight < 150) {
                
                if (!bestCandidate || current.offsetHeight < bestCandidate.offsetHeight) {
                    bestCandidate = current;
                }
            }
            
            if (current.matches && current.matches('p, div, h1, h2, h3, h4, h5, h6, li, blockquote')) {
                if (current.offsetHeight < 100) {
                    return current;
                }
                break;
            }
            
            current = current.parentElement;
        }
        
        if (bestCandidate) {
            return bestCandidate;
        }
        
        current = element;
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.ELEMENT_NODE && current.textContent.trim()) {
                return current;
            }
            current = current.parentElement;
        }
        
        return element;
    }

    selectWordAtPoint(e) {
        const textNode = this.getTextNodeAtPoint(e.clientX, e.clientY);
        if (!textNode) return null;

        const text = textNode.textContent;
        const offset = this.getOffsetInTextNode(textNode, e.clientX, e.clientY);
        
        if (offset === -1) return null;

        const { start, end } = this.getWordBoundaries(text, offset);
        
        if (start < end) {
            const range = document.createRange();
            range.setStart(textNode, start);
            range.setEnd(textNode, end);
            return range;
        }
        
        return null;
    }

    getTextNodeAtPoint(x, y) {
        if (document.caretPositionFromPoint) {
            try {
                const position = document.caretPositionFromPoint(x, y);
                if (position && position.offsetNode && position.offsetNode.nodeType === Node.TEXT_NODE) {
                    return position.offsetNode;
                }
            } catch (e) {
                // Fallback to other methods
            }
        }
        
        if (document.caretRangeFromPoint) {
            try {
                const range = document.caretRangeFromPoint(x, y);
                if (range && range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) {
                    return range.startContainer;
                }
            } catch (e) {
                // Fallback to other methods
            }
        }
        
        const element = document.elementFromPoint(x, y);
        if (!element) return null;
        
        if (element.classList.contains('text-highlight')) {
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            const textNode = walker.nextNode();
            if (textNode) return textNode;
        }
        
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            {
                acceptNode: function(node) {
                    return node.textContent.trim().length > 0 ? 
                        NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                }
            },
            false
        );
        
        let bestTextNode = null;
        let bestDistance = Infinity;
        let textNode;
        
        while (textNode = walker.nextNode()) {
            const range = document.createRange();
            range.selectNodeContents(textNode);
            const rect = range.getBoundingClientRect();
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            
            if (distance < bestDistance) {
                bestDistance = distance;
                bestTextNode = textNode;
            }
        }
        
        return bestTextNode;
    }

    getOffsetInTextNode(textNode, x, y) {
        const text = textNode.textContent;
        if (!text) return 0;
        
        const range = document.createRange();
        let bestOffset = 0;
        let bestDistance = Infinity;
        
        for (let i = 0; i <= text.length; i++) {
            try {
                range.setStart(textNode, i);
                range.setEnd(textNode, Math.min(i + 1, text.length));
                
                const rect = range.getBoundingClientRect();
                if (!rect.width && !rect.height) continue;
                
                const charX = rect.left + rect.width / 2;
                const charY = rect.top + rect.height / 2;
                const distance = Math.sqrt(Math.pow(x - charX, 2) + Math.pow(y - charY, 2));
                
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestOffset = i;
                }
            } catch (e) {
                break;
            }
        }
        
        return Math.min(bestOffset, text.length);
    }

    getWordBoundaries(text, offset) {
        const wordRegex = /[\w''-]/;
        let start = offset;
        let end = offset;

        while (start > 0 && wordRegex.test(text[start - 1])) {
            start--;
        }

        while (end < text.length && wordRegex.test(text[end])) {
            end++;
        }

        if (start === end) {
            if (offset < text.length) {
                end = offset + 1;
            } else if (offset > 0) {
                start = offset - 1;
            }
        }

        if (end - start < 1 && start > 0) {
            start = Math.max(0, offset - 1);
            end = Math.min(text.length, offset + 1);
        }

        return { start, end };
    }

    createHighlightFromSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0 || selection.isCollapsed) return;

        const range = selection.getRangeAt(0);
        if (!this.isInBookContent(range.commonAncestorContainer)) return;

        const text = range.toString().trim();
        if (!text) return;

        // Find the section this highlight belongs to
        const section = this.findContainingSection(range.startContainer);
        if (!section || !section.id) {
            console.warn('Could not find section with ID for highlight');
            return;
        }

        const startChar = this.getCharPositionInSection(section, range.startContainer, range.startOffset);
        const endChar = this.getCharPositionInSection(section, range.endContainer, range.endOffset);
        
        if (startChar === -1 || endChar === -1) {
            console.warn('Could not calculate character positions');
            return;
        }

        const highlightId = this.generateHighlightId();
        const highlightData = {
            id: highlightId,
            pageNum: this.bookReader.currentPage,
            sectionId: section.id,
            startChar: startChar,
            endChar: endChar,
            color: 'yellow',
            comment: '',
            text: text
        };

        const span = document.createElement('span');
        span.className = `text-highlight highlight-${highlightData.color}`;
        span.dataset.highlightId = highlightData.id;

        try {
            range.surroundContents(span);
            this.addHighlight(highlightData);
            
            // Immediately select the new highlight
            setTimeout(() => {
                this.selectHighlight(highlightData);
            }, 50);
            
        } catch (e) {
            console.warn('Could not create highlight:', e);
        }
        
        selection.removeAllRanges();
    }

    findContainingSection(node) {
        let current = node;
        while (current && current !== document.getElementById('bookContent')) {
            if (current.nodeType === Node.ELEMENT_NODE && current.id) {
                return current;
            }
            current = current.parentNode;
        }
        return null;
    }

    getCharPositionInSection(section, targetNode, targetOffset) {
        const walker = document.createTreeWalker(
            section,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let position = 0;
        let textNode;
        
        while (textNode = walker.nextNode()) {
            if (textNode === targetNode) {
                return position + targetOffset;
            }
            position += textNode.textContent.length;
        }
        
        return -1;
    }

    createRangeFromCharPositions(section, startChar, endChar) {
        const walker = document.createTreeWalker(
            section,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let currentPos = 0;
        let textNode;
        let startNode = null, startOffset = 0;
        let endNode = null, endOffset = 0;
        
        while (textNode = walker.nextNode()) {
            const nodeLength = textNode.textContent.length;
            
            if (!startNode && currentPos + nodeLength >= startChar) {
                startNode = textNode;
                startOffset = startChar - currentPos;
            }
            
            if (!endNode && currentPos + nodeLength >= endChar) {
                endNode = textNode;
                endOffset = endChar - currentPos;
                break;
            }
            
            currentPos += nodeLength;
        }
        
        if (!startNode || !endNode) return null;
        
        const range = document.createRange();
        range.setStart(startNode, startOffset);
        range.setEnd(endNode, endOffset);
        return range;
    }

    findHighlightById(highlightId) {
        for (const [pageNum, highlights] of this.highlights) {
            const highlight = highlights.find(h => h.id === highlightId);
            if (highlight) return highlight;
        }
        return null;
    }

    addHighlight(highlightData) {
        const pageNum = highlightData.pageNum;
        if (!this.highlights.has(pageNum)) {
            this.highlights.set(pageNum, []);
        }
        this.highlights.get(pageNum).push(highlightData);
        this.saveHighlights();
    }

    selectHighlight(highlightData) {
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
            el.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(handle => {
                handle.remove();
            });
        });

        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (element) {
            element.classList.add('selected');
            this.selectedHighlight = highlightData;
            this.addSmartResizeHandles(element);
            this.updateHandleColors(element, highlightData.color);
            this.showPopup(highlightData);
        }
    }

    addSmartResizeHandles(element) {
        if (!this.selectedHighlight || element.dataset.highlightId !== this.selectedHighlight.id) {
            return;
        }
        
        document.querySelectorAll(`[data-highlight-id="${element.dataset.highlightId}"]`).forEach(el => {
            el.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(handle => {
                handle.remove();
            });
        });
        
        const allHighlightElements = Array.from(document.querySelectorAll(`[data-highlight-id="${element.dataset.highlightId}"]`));
        
        if (allHighlightElements.length === 0) return;
        
        const firstElement = allHighlightElements[0];
        const leftHandle = document.createElement('div');
        leftHandle.className = 'resize-handle-left';
        firstElement.appendChild(leftHandle);
        
        const lastElement = allHighlightElements[allHighlightElements.length - 1];
        const rightHandle = document.createElement('div');
        rightHandle.className = 'resize-handle-right';
        lastElement.appendChild(rightHandle);
    }

    showPopup(highlightData) {
        const element = document.querySelector(`[data-highlight-id="${highlightData.id}"]`);
        if (!element) {
            console.warn('Could not find highlight element for popup');
            return;
        }

        const rect = element.getBoundingClientRect();
        const popup = this.popup;

        const commentDiv = document.getElementById('highlightComment');
        const textarea = commentDiv.querySelector('.comment-input');
        
        const commentText = highlightData.comment || '';
        textarea.value = commentText;
        this.autoResizeTextarea(textarea);
        
        document.querySelectorAll('[data-color]').forEach(pill => {
            const isSelected = pill.dataset.color === highlightData.color;
            if (isSelected) {
                pill.style.borderColor = '#3b82f6';
                pill.style.transform = 'scale(1.2)';
                pill.style.boxShadow = '0 4px 8px rgba(59, 130, 246, 0.3)';
            } else {
                pill.style.borderColor = 'transparent';
                pill.style.transform = 'scale(1)';
                pill.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            }
        });

        popup.style.display = 'block';
        
        requestAnimationFrame(() => {
            const popupRect = popup.getBoundingClientRect();
            
            let left = rect.left + (rect.width / 2) - (popupRect.width / 2);
            left = Math.max(10, Math.min(left, window.innerWidth - popupRect.width - 10));
            
            let top = rect.top - popupRect.height - 15;
            if (top < 10) {
                top = rect.bottom + 15;
            }
            
            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
            popup.classList.add('show');
        });
    }

    hidePopup() {
        const popup = this.popup;
        popup.classList.remove('show');
        
        if (this.selectedHighlight) {
            const textarea = document.querySelector('.comment-input');
            if (textarea) {
                const newComment = textarea.value.trim();
                if (this.selectedHighlight.comment !== newComment) {
                    this.selectedHighlight.comment = newComment;
                    this.saveHighlights();
                }
            }
        }
        
        setTimeout(() => {
            popup.style.display = 'none';
        }, 200);
        
        this.selectedHighlight = null;
        this.isEditingComment = false;
        
        document.querySelectorAll('.text-highlight.selected').forEach(el => {
            el.classList.remove('selected');
        });
        
        document.querySelectorAll('.resize-handle-left, .resize-handle-right').forEach(handle => {
            handle.remove();
        });
        
        const commentDiv = document.getElementById('highlightComment');
        commentDiv.classList.remove('editing');
    }

    startEditing() {
        const commentDiv = document.getElementById('highlightComment');
        const textarea = commentDiv.querySelector('.comment-input');
        
        commentDiv.classList.add('editing');
        textarea.focus();
        
        this.autoResizeTextarea(textarea);
        
        let saveTimeout;
        const debouncedSave = () => {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                if (this.selectedHighlight) {
                    const newComment = textarea.value.trim();
                    if (this.selectedHighlight.comment !== newComment) {
                        this.selectedHighlight.comment = newComment;
                        this.saveHighlights();
                    }
                }
            }, 300);
        };
        
        textarea.removeEventListener('input', this.commentInputHandler);
        textarea.removeEventListener('blur', this.commentBlurHandler);
        
        this.commentInputHandler = () => {
            this.autoResizeTextarea(textarea);
            debouncedSave();
        };
        
        this.commentBlurHandler = () => {
            if (this.selectedHighlight) {
                const newComment = textarea.value.trim();
                if (this.selectedHighlight.comment !== newComment) {
                    this.selectedHighlight.comment = newComment;
                    this.saveHighlights();
                }
            }
        };
        
        textarea.addEventListener('input', this.commentInputHandler);
        textarea.addEventListener('blur', this.commentBlurHandler);
    }

    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        const newHeight = Math.max(20, textarea.scrollHeight);
        textarea.style.height = newHeight + 'px';
        textarea.rows = Math.max(1, Math.ceil(newHeight / 20));
    }

    changeHighlightColor(color) {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            element.classList.remove(`highlight-${this.selectedHighlight.color}`);
            element.classList.add(`highlight-${color}`);
            
            this.selectedHighlight.color = color;
            
            // Update handle colors to match new highlight color
            this.updateHandleColors(element, color);
            
            document.querySelectorAll('[data-color]').forEach(pill => {
                const isSelected = pill.dataset.color === color;
                if (isSelected) {
                    pill.style.borderColor = '#3b82f6';
                    pill.style.transform = 'scale(1.2)';
                    pill.style.boxShadow = '0 4px 8px rgba(59, 130, 246, 0.3)';
                } else {
                    pill.style.borderColor = 'transparent';
                    pill.style.transform = 'scale(1)';
                    pill.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                }
            });
            
            this.saveHighlights();
        }
    }

    deleteHighlight() {
        if (!this.selectedHighlight) return;

        const element = document.querySelector(`[data-highlight-id="${this.selectedHighlight.id}"]`);
        if (element) {
            const parent = element.parentNode;
            const textNode = document.createTextNode(element.textContent);
            parent.replaceChild(textNode, element);
            parent.normalize();
        }

        const pageHighlights = this.highlights.get(this.selectedHighlight.pageNum);
        if (pageHighlights) {
            const index = pageHighlights.findIndex(h => h.id === this.selectedHighlight.id);
            if (index !== -1) {
                pageHighlights.splice(index, 1);
            }
        }

        this.saveHighlights();
        this.hidePopup();
    }

    restoreHighlights() {
        const pageHighlights = this.highlights.get(this.bookReader.currentPage);
        if (!pageHighlights || pageHighlights.length === 0) return;

        pageHighlights.forEach((highlightData) => {
            // Skip if highlight already exists
            if (document.querySelector(`[data-highlight-id="${highlightData.id}"]`)) {
                return;
            }

            try {
                const section = document.getElementById(highlightData.sectionId);
                if (!section) {
                    console.warn(`Section ${highlightData.sectionId} not found for highlight ${highlightData.id}`);
                    return;
                }

                const range = this.createRangeFromCharPositions(section, highlightData.startChar, highlightData.endChar);
                if (!range || range.collapsed) return;

                const span = document.createElement('span');
                span.className = `text-highlight highlight-${highlightData.color}`;
                span.dataset.highlightId = highlightData.id;
                
                try {
                    range.surroundContents(span);
                } catch (e) {
                    // Silently ignore surroundContents errors
                }
                
            } catch (e) {
                console.warn(`Failed to restore highlight ${highlightData.id}:`, e);
            }
        });

        this.addContentEventListeners();
    }

    isInBookContent(node) {
        const bookContent = document.getElementById('bookContent');
        while (node) {
            if (node === bookContent) return true;
            node = node.parentNode;
        }
        return false;
    }

    generateHighlightId() {
        return 'highlight_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    saveHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        
        try {
            const metadata = this.bookReader.getStoredMetadata();
            
            if (!metadata[bookName]) {
                metadata[bookName] = {};
            }
            
            if (!metadata[bookName].pages) {
                metadata[bookName].pages = {};
            }
            
            this.highlights.forEach((highlights, pageNum) => {
                if (highlights.length > 0) {
                    if (!metadata[bookName].pages[pageNum]) {
                        metadata[bookName].pages[pageNum] = {};
                    }
                    metadata[bookName].pages[pageNum].highlights = highlights;
                } else {
                    if (metadata[bookName].pages[pageNum]) {
                        delete metadata[bookName].pages[pageNum].highlights;
                        if (Object.keys(metadata[bookName].pages[pageNum]).length === 0) {
                            delete metadata[bookName].pages[pageNum];
                        }
                    }
                }
            });
            
            localStorage.setItem('bookMetadata', JSON.stringify(metadata));
            
        } catch (e) {
            console.warn('Failed to save highlights to bookMetadata:', e);
        }
    }

    loadHighlights() {
        if (!this.bookReader.currentFile?.name) return;
        
        const bookName = this.bookReader.currentFile.name.replace(/\.html$/, '');
        
        try {
            const metadata = this.bookReader.getStoredMetadata();
            const bookData = metadata[bookName];
            
            if (bookData && bookData.pages) {
                this.highlights.clear();
                
                Object.entries(bookData.pages).forEach(([pageNum, pageData]) => {
                    if (pageData.highlights && pageData.highlights.length > 0) {
                        this.highlights.set(parseInt(pageNum), pageData.highlights);
                    }
                });
                return;
            }
            
        } catch (e) {
            console.warn('Failed to load highlights:', e);
        }
    }
}

class BookReader {
    constructor() {
        this.currentFile = null;
        this.currentPage = 0;
        this.pages = [];
        this.tocItems = [];
        this.isTransitioning = false;
        this.styleProcessor = new StyleProcessor();
        this.setupEventListeners();
        this.setupIntersectionObserver();
        this.initializeTheme();
        this.highlightManager = new HighlightManager(this);
    }

    initializeTheme() {
        const storedTheme = localStorage.getItem('darkMode');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const isDark = storedTheme === 'true' || (!storedTheme && systemPrefersDark);
        
        if (isDark) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        
        const toggleButton = document.getElementById('darkModeToggle');
        toggleButton.addEventListener('click', () => {
            const newDarkMode = !document.documentElement.classList.contains('dark');
            document.documentElement.classList.toggle('dark', newDarkMode);
            localStorage.setItem('darkMode', newDarkMode.toString());
            
            // Update color pills when theme changes
            if (this.highlightManager) {
                this.highlightManager.updateColorPillColors();
            }
        });

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('darkMode')) {
                const newDarkMode = e.matches;
                document.documentElement.classList.toggle('dark', newDarkMode);
                
                // Update color pills when system theme changes
                if (this.highlightManager) {
                    this.highlightManager.updateColorPillColors();
                }
            }
        });
    }

    setupIntersectionObserver() {
        const contentWrapper = document.getElementById('contentWrapper');
        let isAtBottom = false;
        let isAtTop = true;

        const options = {
            root: null,
            rootMargin: '0px',
            threshold: 0
        };

        const topObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtTop = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        const bottomObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                isAtBottom = entry.isIntersecting;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            });
        }, options);

        topObserver.observe(document.getElementById('topSentinel'));
        bottomObserver.observe(document.getElementById('bottomSentinel'));

        let scrollSaveTimeout;
        contentWrapper.addEventListener('scroll', () => {
            const atBottom = contentWrapper.scrollHeight - contentWrapper.scrollTop <= contentWrapper.clientHeight + 1;
            if (atBottom !== isAtBottom) {
                isAtBottom = atBottom;
                this.updateControlsVisibility(isAtTop, isAtBottom);
            }
            
            clearTimeout(scrollSaveTimeout);
            scrollSaveTimeout = setTimeout(() => {
                this.saveCurrentState();
            }, 300);
        });
    }

    updateControlsVisibility(isAtTop, isAtBottom) {
        const header = document.getElementById('header');
        const footer = document.getElementById('footer');
        
        if (!header || !footer) return;
        
        const updateClasses = (element, shouldBeVisible) => {
            if (shouldBeVisible) {
                element.classList.remove('controls-hidden');
                element.classList.add('controls-visible');
            } else {
                element.classList.remove('controls-visible');
                element.classList.add('controls-hidden');
            }
        };

        if (isAtTop) {
            updateClasses(header, true);
            updateClasses(footer, true);
        } else {
            updateClasses(header, false);
            updateClasses(footer, isAtBottom);
        }
    }

    setupEventListeners() {
        document.getElementById('prevButton').addEventListener('click', () => this.prevPage());
        document.getElementById('nextButton').addEventListener('click', () => this.nextPage());
        document.getElementById('tocSelect').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
        
        window.addEventListener('beforeunload', () => {
            this.saveCurrentState();
        });
        
        setInterval(() => {
            if (this.currentFile) {
                this.saveCurrentState();
            }
        }, 30000);
    }

    getStoredMetadata() {
        try {
            const stored = localStorage.getItem('bookMetadata');
            const metadata = stored ? JSON.parse(stored) : {};
            return metadata;
        } catch (e) {
            console.warn('⚠️ Could not load book metadata:', e);
            return {};
        }
    }

    saveCurrentState() {
        if (!this.currentFile?.name) return;
        
        const metadata = this.getStoredMetadata();
        const bookName = this.currentFile.name.replace(/\.html$/, '');
        
        const contentWrapper = document.getElementById('contentWrapper');
        const scrollTop = contentWrapper ? contentWrapper.scrollTop : 0;
        
        let lineMarkerPath = null;
        if (this.highlightManager.currentLineHighlight) {
            const section = this.highlightManager.findContainingSection(this.highlightManager.currentLineHighlight);
            if (section && section.id) {
                lineMarkerPath = {
                    sectionId: section.id
                };
            }
        }
        
        if (!metadata[bookName]) {
            metadata[bookName] = {};
        }
        
        metadata[bookName].lastPage = this.currentPage;
        metadata[bookName].scrollTop = scrollTop;
        metadata[bookName].lineMarkerPath = lineMarkerPath;
        
        try {
            localStorage.setItem('bookMetadata', JSON.stringify(metadata));
        } catch (e) {
            console.warn('⚠️ Could not save book metadata:', e);
        }
    }

    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const content = await file.text();
            this.currentFile = file;
            const bookName = file.name.replace(/\.html$/, '');
            
            document.getElementById('currentBookTitle').textContent = bookName;
            this.parseBook(content);
            
            if (this.pages.length === 0) {
                throw new Error('No readable content found in the book file');
            }
            
            const savedState = this.getStoredMetadata()[bookName] || {};
            this.currentPage = this.validatePageNumber(savedState.lastPage) ? savedState.lastPage : 0;
            
            this.highlightManager.loadHighlights();
            this.updateDisplay();
            
            await this.restoreBookState(savedState);
            
        } catch (error) {
            console.error('❌ Error loading book:', error);
            alert('Error reading file: ' + error.message);
        }

        event.target.value = '';
    }

    validatePageNumber(pageNum) {
        return pageNum !== undefined && 
               pageNum >= 0 && 
               pageNum < this.pages.length && 
               this.pages.length > 0;
    }

    async restoreBookState(savedState) {
        await this.waitForDOM(200);
        this.highlightManager.restoreHighlights();
        await this.waitForDOM(100);
        
        if (savedState.lineMarkerPath) {
            this.restoreLineMarker(savedState.lineMarkerPath);
        }
        
        await this.restoreScrollPosition(savedState.scrollTop);
    }

    waitForDOM(delay = 100) {
        return new Promise(resolve => {
            setTimeout(resolve, delay);
        });
    }

    restoreLineMarker(lineMarkerPath) {
        try {
            if (!lineMarkerPath || !lineMarkerPath.sectionId) return;
            
            const section = document.getElementById(lineMarkerPath.sectionId);
            if (section) {
                section.classList.add('line-highlight');
                this.highlightManager.currentLineHighlight = section;
            }
        } catch (e) {
            console.warn('⚠️ Error restoring line marker:', e);
        }
    }

    async restoreScrollPosition(scrollTop) {
        if (!scrollTop || scrollTop <= 0) return;
        
        const contentWrapper = document.getElementById('contentWrapper');
        if (!contentWrapper) return;
        
        for (let attempt = 0; attempt < 5; attempt++) {
            await new Promise(resolve => setTimeout(resolve, 50 * (attempt + 1)));
            contentWrapper.scrollTop = scrollTop;
            
            const actualScroll = contentWrapper.scrollTop;
            if (Math.abs(actualScroll - scrollTop) <= 10) {
                return;
            }
        }
    }

    parseBook(content) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        
        // Extract and process styles first
        const processedStyles = this.styleProcessor.extractAndProcessStyles(doc);
        this.styleProcessor.injectStyles(processedStyles);
        
        const chapters = doc.querySelectorAll('.chapter-loaded');
        this.pages = [];
        this.tocItems = [['Cover', 0]];

        if (chapters.length === 0) {
            const body = doc.body;
            if (body && body.textContent.trim()) {
                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-loaded';
                chapterDiv.innerHTML = this.cleanContent(body);
                this.pages.push(chapterDiv.outerHTML);
                this.tocItems.push(['Chapter 1', 0]);
            } else {
                console.warn('⚠️ No valid content found in HTML file');
                this.pages.push('<div class="chapter-loaded"><p>No content found in this book.</p></div>');
            }
        } else {
            chapters.forEach((chapter, index) => {
                const titleElem = chapter.querySelector('h1, h2, h3');
                if (titleElem) {
                    const title = titleElem.textContent.trim();
                    this.tocItems.push([title, this.pages.length]);
                } else {
                    this.tocItems.push([`Chapter ${index + 1}`, this.pages.length]);
                }

                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-loaded';
                chapterDiv.innerHTML = this.cleanContent(chapter);
                this.pages.push(chapterDiv.outerHTML);
            });
        }

        this.updateTOC();
    }

    cleanContent(element) {
        const clone = element.cloneNode(true);
        
        const cleanup = (node) => {
            if (node.nodeType === 1) {
                ['data-originalfontfamily', 'data-originalfontsize', 
                'data-originalcolor', 'data-originalbg', 'onload', 'onerror']
                    .forEach(attr => {
                        if (node.hasAttribute(attr)) {
                            node.removeAttribute(attr);
                        }
                    });

                if (node.hasAttribute('style')) {
                    const style = node.getAttribute('style');
                    const newStyle = style
                        .replace(/background-color:[^;]+;?/gi, '')
                        .replace(/color:[^;]+;?/gi, '')
                        .trim();
                    
                    if (newStyle) {
                        node.setAttribute('style', newStyle);
                    } else {
                        node.removeAttribute('style');
                    }
                }
                
                node.childNodes.forEach(cleanup);
            }
        };
        
        cleanup(clone);
        return clone.innerHTML;
    }

    updateTOC() {
        const tocSelect = document.getElementById('tocSelect');
        tocSelect.innerHTML = '<option value="" class="bg-white dark:bg-true-black">Table of Contents...</option>';
        
        this.tocItems.forEach(([title, pageNum]) => {
            const option = document.createElement('option');
            option.value = pageNum;
            option.textContent = title;
            option.className = 'bg-white dark:bg-true-black';
            tocSelect.appendChild(option);
        });
    }

    scrollToTop() {
        const contentWrapper = document.getElementById('contentWrapper');
        
        const scrollMethods = [
            () => contentWrapper.scrollTo({
                top: 0,
                behavior: 'instant',
            }),
            () => contentWrapper.scrollTop = 0,
            () => contentWrapper.scrollTo(0, 0),
            () => contentWrapper.parentElement?.scrollTo(0, 0),
        ];

        scrollMethods.forEach(method => {
            try {
                method();
            } catch (e) {
                console.error('⚠️ Scroll method failed:', e);
            }
        });

        requestAnimationFrame(() => {
            if (contentWrapper.scrollTop !== 0) {
                contentWrapper.scrollTop = 0;
            }
        });
    }

    scrollToBottom() {
        const contentWrapper = document.getElementById('contentWrapper');
        contentWrapper.scrollTo({
            top: contentWrapper.scrollHeight,
            behavior: 'instant'
        });
    }

    prevPage() {
        if (this.currentPage > 0) {
            this.saveCurrentState();
            this.currentPage--;
            // Clear old styles when changing pages
            this.styleProcessor.clearStyles();
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToBottom();
            });
        }
    }

    nextPage() {
        if (this.currentPage < this.pages.length - 1 && !this.isTransitioning) {
            this.saveCurrentState();
            this.isTransitioning = true;
            this.currentPage++;
            // Clear old styles when changing pages
            this.styleProcessor.clearStyles();
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.isTransitioning = false;
            });
        }
    }

    goToPage(pageNum) {
        if (pageNum >= 0 && pageNum < this.pages.length) {
            this.saveCurrentState();
            this.currentPage = pageNum;
            // Clear old styles when changing pages
            this.styleProcessor.clearStyles();
            this.updateDisplay();
            requestAnimationFrame(() => {
                this.scrollToTop();
            });
        }
    }

    updateDisplay() {
        if (!this.pages.length) {
            document.getElementById('bookContent').innerHTML = 
                '<div class="chapter-loaded text-center text-gray-400 italic">No book selected</div>';
            return;
        }

        if (this.highlightManager.currentLineHighlight) {
            this.highlightManager.currentLineHighlight.classList.remove('line-highlight');
            this.highlightManager.currentLineHighlight = null;
        }

        this.highlightManager.hidePopup();

        const contentWrapper = document.getElementById('contentWrapper');
        const oldContent = document.getElementById('bookContent');
        
        oldContent.remove();
        void contentWrapper.offsetHeight;
        
        const newContent = document.createElement('div');
        newContent.id = 'bookContent';
        newContent.className = 'max-w-3xl mx-auto px-4';
        newContent.innerHTML = this.pages[this.currentPage];
        
        contentWrapper.insertBefore(newContent, contentWrapper.querySelector('#bottomSentinel'));
        void contentWrapper.offsetHeight;
        
        document.getElementById('pageIndicator').textContent = 
            `${this.currentPage + 1} / ${this.pages.length}`;
        
        document.getElementById('prevButton').disabled = (this.currentPage === 0);
        document.getElementById('nextButton').disabled = (this.currentPage === this.pages.length - 1);
        
        document.getElementById('tocSelect').value = this.currentPage;
        
        this.highlightManager.addContentEventListeners();

        setTimeout(() => {
            this.highlightManager.restoreHighlights();
        }, 100);
    }
}

window.addEventListener('DOMContentLoaded', () => {
    window.bookReader = new BookReader();
});
</script>
</body>
</html>
